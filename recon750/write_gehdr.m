function write_gehdr(id, hdr)
%WRITE_GEHDR  Write the header of a GE raw data file
%
%  usage: write_gehdr(id, hdr)
%
%  id:    integer file identifier obtained from fopen()
%
%  hdr:   a structure generated by read_gehdr() with hdr.rdb.rdbm_rev = 20.006F
%
%  e.g.:  >> id = fopen('P12345.7', 'w', 'l');
%         >> write_gehdr(id, hdr);

%  This script was generated from GE source using 'gehdr2matlab20' modified from
%  'gehdr2matlab' written by DB Clayton

% $Id: write_gehdr.m 1279 2014-03-24 20:06:25Z klitinas $
% $HeadURL: svn+ssh://klitinas@anger.engin.umich.edu/svn/matlab/img/trunk/write_gehdr.m $

fwrite(id, hdr.rdb.rdbm_rev, 'float');  
fwrite(id, hdr.rdb.run_int, 'int');  % Rdy pkt Run Number 
fwrite(id, hdr.rdb.scan_seq, 'short');  % Rdy pkt Sequence Number 
fwrite(id, hdr.rdb.run_char, 'char');  % Rdy pkt Run no in char 
fwrite(id, hdr.rdb.scan_date, 'char');  % 
fwrite(id, hdr.rdb.scan_time, 'char');  % 
fwrite(id, hdr.rdb.logo, 'char');  % rdbm used to verify file 
fwrite(id, hdr.rdb.file_contents, 'short');  % Data type 0=emp 1=nrec 2=rw 0, 1, 2 
fwrite(id, hdr.rdb.lock_mode, 'short');  % unused 
fwrite(id, hdr.rdb.dacq_ctrl, 'short');  % rhdacqctrl bit mask 15 bits 
fwrite(id, hdr.rdb.recon_ctrl, 'short');  % rhrcctrl bit mask 15 bits 
fwrite(id, hdr.rdb.exec_ctrl, 'ushort');  % rhexecctrl bit mask 15 bits 
fwrite(id, hdr.rdb.scan_type, 'short');  % bit mask 15 bits 
fwrite(id, hdr.rdb.data_collect_type, 'short');  % rhtype bit mask 15 bits 
fwrite(id, hdr.rdb.data_format, 'short');  % rhformat bit mask 15 bits 
fwrite(id, hdr.rdb.recon, 'short');  % rhrecon proc-a-son recon 0 - 100 
fwrite(id, hdr.rdb.datacq, 'short');  % rhdatacq proc-a-son dacq 
fwrite(id, hdr.rdb.npasses, 'short');  % rhnpasses passes for a scan 0 - 256 
fwrite(id, hdr.rdb.npomp, 'short');  % rhnpomp pomp group slices 1,2 
fwrite(id, hdr.rdb.nslices, 'ushort');  % rhnslices slices in a pass 0 - 256 
fwrite(id, hdr.rdb.nechoes, 'short');  % rhnecho echoes of a slice 1 - 32 
fwrite(id, hdr.rdb.navs, 'short');  % rhnavs num of excitiations 1 - 32727 
fwrite(id, hdr.rdb.nframes, 'short');  % rhnframes yres 0 - 1024 
fwrite(id, hdr.rdb.baseline_views, 'short');  % rhbline baselines 0 - 1028 
fwrite(id, hdr.rdb.hnover, 'short');  % rhhnover overscans 0 - 1024 
fwrite(id, hdr.rdb.frame_size, 'ushort');  % rhfrsize xres 0 - 32768 
fwrite(id, hdr.rdb.point_size, 'short');  % rhptsize 2 - 4 
fwrite(id, hdr.rdb.vquant, 'short');  % rhvquant 3d volumes 1 
fwrite(id, hdr.rdb.cheart, 'short');  % RX Cine heart phases 1 - 32 
fwrite(id, hdr.rdb.ctr, 'float');  % RX Cine TR in sec 0 - 3.40282e38
fwrite(id, hdr.rdb.ctrr, 'float');  % RX Cine RR in sec 0 - 30.0 
fwrite(id, hdr.rdb.initpass, 'short');  % rhinitpass allocate passes 0 - 32767 
fwrite(id, hdr.rdb.incrpass, 'short');  % rhincrpass tps autopauses 0 - 32767 
fwrite(id, hdr.rdb.method_ctrl, 'short');  % rhmethod 0=recon, 1=psd 0, 1 
fwrite(id, hdr.rdb.da_xres, 'ushort');  % rhdaxres 0 - 32768 
fwrite(id, hdr.rdb.da_yres, 'short');  % rhdayres 0 - 2049 
fwrite(id, hdr.rdb.rc_xres, 'short');  % rhrcxres 0 - 1024 
fwrite(id, hdr.rdb.rc_yres, 'short');  % rhrcyres 0 - 1024 
fwrite(id, hdr.rdb.im_size, 'short');  % rhimsize 0 - 512 
fwrite(id, hdr.rdb.rc_zres, 'int');  % power of 2 > rhnslices 0 - 128 
fwrite(id, hdr.rdb.raw_pass_size_deprecated, 'int');  
fwrite(id, hdr.rdb.sspsave_deprecated, 'int');  
fwrite(id, hdr.rdb.udasave_deprecated, 'int');  
fwrite(id, hdr.rdb.fermi_radius, 'float');  % rhfermr fermi radius 0 - 3.40282e38
fwrite(id, hdr.rdb.fermi_width, 'float');  % rhfermw fermi width 0 - 3.40282e38
fwrite(id, hdr.rdb.fermi_ecc, 'float');  % rhferme fermi excentiricty 0 - 3.40282e38
fwrite(id, hdr.rdb.clip_min, 'float');  % rhclipmin 4x IP limit +-16383 
fwrite(id, hdr.rdb.clip_max, 'float');  % rhclipmax 4x IP limit +-16383 
fwrite(id, hdr.rdb.default_offset, 'float');  % rhdoffset default offset = 0 +-3.40282e38 
fwrite(id, hdr.rdb.xoff, 'float');  % rhxoff scroll img in x +-256 
fwrite(id, hdr.rdb.yoff, 'float');  % rhyoff scroll img in y +-256 
fwrite(id, hdr.rdb.nwin, 'float');  % rhnwin hecho window width 0 - 256 
fwrite(id, hdr.rdb.ntran, 'float');  % rhntran hecho trans width 0 - 256 
fwrite(id, hdr.rdb.scalei, 'float');  % PS rhscalei +-3.40282e38 
fwrite(id, hdr.rdb.scaleq, 'float');  % PS rhscaleq def = 0 +-3.40282e38 
fwrite(id, hdr.rdb.rotation, 'short');  % RX 0 90 180 270 deg 0 - 3 
fwrite(id, hdr.rdb.transpose, 'short');  % RX 0, 1 n / y transpose 0 - 1
fwrite(id, hdr.rdb.kissoff_views, 'short');  % rhblank zero image views 0 - 512 
fwrite(id, hdr.rdb.slblank, 'short');  % rhslblank slice blank 3d 0 - 128 
fwrite(id, hdr.rdb.gradcoil, 'short');  % RX 0=off 1=Schnk 2=Rmr 0 - 2 
fwrite(id, hdr.rdb.ddaover, 'short');  % rhddaover unused 
fwrite(id, hdr.rdb.sarr, 'short');  % SARR bit mask 15 bits 
fwrite(id, hdr.rdb.fd_tr, 'short');  % SARR feeder timing info 
fwrite(id, hdr.rdb.fd_te, 'short');  % SARR feeder timing info 
fwrite(id, hdr.rdb.fd_ctrl, 'short');  % SARR control of feeder 
fwrite(id, hdr.rdb.algor_num, 'short');  % SARR df decimation ratio 
fwrite(id, hdr.rdb.fd_df_dec, 'short');  % SARR which feeder algor 
buff = [hdr.rdb.dab_start_rcv, hdr.rdb.dab_stop_rcv];  % kluge for type RDB_MULTI_RCV_TYPE
buff(1:2:end) = hdr.rdb.dab_start_rcv;  % kluge for type RDB_MULTI_RCV_TYPE
buff(2:2:end) = hdr.rdb.dab_stop_rcv;  % kluge for type RDB_MULTI_RCV_TYPE
fwrite(id, buff, 'short');  % kluge for type RDB_MULTI_RCV_TYPE
fwrite(id, hdr.rdb.user0, 'float');  % rhuser0 +-3.40282e38 
fwrite(id, hdr.rdb.user1, 'float');  % rhuser1 +-3.40282e38 
fwrite(id, hdr.rdb.user2, 'float');  % rhuser2 +-3.40282e38 
fwrite(id, hdr.rdb.user3, 'float');  % rhuser3 +-3.40282e38 
fwrite(id, hdr.rdb.user4, 'float');  % rhuser4 +-3.40282e38 
fwrite(id, hdr.rdb.user5, 'float');  % rhuser5 +-3.40282e38 
fwrite(id, hdr.rdb.user6, 'float');  % rhuser6 +-3.40282e38 
fwrite(id, hdr.rdb.user7, 'float');  % rhuser7 +-3.40282e38 
fwrite(id, hdr.rdb.user8, 'float');  % rhuser8 +-3.40282e38 
fwrite(id, hdr.rdb.user9, 'float');  % rhuser9 +-3.40282e38 
fwrite(id, hdr.rdb.user10, 'float');  % rhuser10 +-3.40282e38 
fwrite(id, hdr.rdb.user11, 'float');  % rhuser11 +-3.40282e38 
fwrite(id, hdr.rdb.user12, 'float');  % rhuser12 +-3.40282e38 
fwrite(id, hdr.rdb.user13, 'float');  % rhuser13 +-3.40282e38 
fwrite(id, hdr.rdb.user14, 'float');  % rhuser14 +-3.40282e38 
fwrite(id, hdr.rdb.user15, 'float');  % rhuser15 +-3.40282e38 
fwrite(id, hdr.rdb.user16, 'float');  % rhuser16 +-3.40282e38 
fwrite(id, hdr.rdb.user17, 'float');  % rhuser17 +-3.40282e38 
fwrite(id, hdr.rdb.user18, 'float');  % rhuser18 +-3.40282e38 
fwrite(id, hdr.rdb.user19, 'float');  % rhuser19 +-3.40282e38 
fwrite(id, hdr.rdb.v_type, 'int');  % rhvtype bit mask 31 bits 
fwrite(id, hdr.rdb.v_coefxa, 'float');  % RX x flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefxb, 'float');  % RX x flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefxc, 'float');  % RX x flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefxd, 'float');  % RX x flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefya, 'float');  % RX y flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefyb, 'float');  % RX y flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefyc, 'float');  % RX y flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefyd, 'float');  % RX y flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefza, 'float');  % RX z flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefzb, 'float');  % RX z flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefzc, 'float');  % RX z flow direction control 0 - 4 
fwrite(id, hdr.rdb.v_coefzd, 'float');  % RX z flow direction control 0 - 4 
fwrite(id, hdr.rdb.vm_coef1, 'float');  % RX weight for mag image 1 0 - 1 
fwrite(id, hdr.rdb.vm_coef2, 'float');  % RX weight for mag image 2 0 - 1 
fwrite(id, hdr.rdb.vm_coef3, 'float');  % RX weight for mag image 3 0 - 1 
fwrite(id, hdr.rdb.vm_coef4, 'float');  % RX weight for mag image 4 0 - 1 
fwrite(id, hdr.rdb.v_venc, 'float');  % RX vel encodeing cm / sec 0.001 - 5000 
fwrite(id, hdr.rdb.spectral_width, 'float');  % specwidth filter width kHz 500 - 3355432 
fwrite(id, hdr.rdb.csi_dims, 'short');  % spectro 
fwrite(id, hdr.rdb.xcsi, 'short');  % rhspecrescsix 2 - 64 
fwrite(id, hdr.rdb.ycsi, 'short');  % rhspecrescsiy 2 - 64 
fwrite(id, hdr.rdb.zcsi, 'short');  % spectro 
fwrite(id, hdr.rdb.roilenx, 'float');  % RX x csi volume dimension 
fwrite(id, hdr.rdb.roileny, 'float');  % RX y csi volume dimension 
fwrite(id, hdr.rdb.roilenz, 'float');  % RX z csi volume dimension 
fwrite(id, hdr.rdb.roilocx, 'float');  % RX x csi volume center 
fwrite(id, hdr.rdb.roilocy, 'float');  % RX y csi volume center 
fwrite(id, hdr.rdb.roilocz, 'float');  % RX z csi volume center 
fwrite(id, hdr.rdb.numdwell, 'float');  % specdwells 0 - 3.40282e38
fwrite(id, hdr.rdb.ps_command, 'int');  % PS internal use only 
fwrite(id, hdr.rdb.ps_mps_r1, 'int');  % PS MPS R1 setting 1 - 7 
fwrite(id, hdr.rdb.ps_mps_r2, 'int');  % PS MPS R2 setting 1 - 30 
fwrite(id, hdr.rdb.ps_mps_tg, 'int');  % PS MPS Transmit gain setting 0 - 200
fwrite(id, hdr.rdb.ps_mps_freq, 'uint');  % PS MPS Center frequency hz +-3.40282e38 
fwrite(id, hdr.rdb.ps_aps_r1, 'int');  % PS APS R1 setting 1 - 7 
fwrite(id, hdr.rdb.ps_aps_r2, 'int');  % PS APS R2 setting 1 - 30 
fwrite(id, hdr.rdb.ps_aps_tg, 'int');  % PS APS Transmit gain setting 0 - 200
fwrite(id, hdr.rdb.ps_aps_freq, 'uint');  % PS APS Center frequency hz +-3.40282e38 
fwrite(id, hdr.rdb.ps_scalei, 'float');  % PS rational scaling +-3.40282e38 
fwrite(id, hdr.rdb.ps_scaleq, 'float');  % PS unused 
fwrite(id, hdr.rdb.ps_snr_warning, 'int');  % PS noise test 0=16 1=32 bits 0, 1 
fwrite(id, hdr.rdb.ps_aps_or_mps, 'int');  % PS prescan order logic 0 - 5 
fwrite(id, hdr.rdb.ps_mps_bitmap, 'int');  % PS bit mask 4 bits
fwrite(id, hdr.rdb.ps_powerspec, 'char');  % PS 
fwrite(id, hdr.rdb.ps_filler1, 'int');  % PS filler 
fwrite(id, hdr.rdb.ps_filler2, 'int');  % PS filler 
fwrite(id, hdr.rdb.obsolete1, 'float');  % PS mean noise each receiver +-3.40282e38 
fwrite(id, hdr.rdb.obsolete2, 'float');  % PS noise calc for muti rec +-3.40282e38 
fwrite(id, hdr.rdb.halfecho, 'short');  % spectro full, half echo 0, 1 
fwrite(id, hdr.rdb.im_size_y, 'short');  % rh???? 0 - 512 
fwrite(id, hdr.rdb.data_collect_type1, 'int');  % rh???? bit mask 31 bits 
fwrite(id, hdr.rdb.freq_scale, 'float');  % rh???? freq k-space step +-3.40282e38 
fwrite(id, hdr.rdb.phase_scale, 'float');  % rh???? freq k-space step +-3.40282e38 
fwrite(id, hdr.rdb.ovl, 'short');  % rhovl - overlaps for MOTSA 
fwrite(id, hdr.rdb.pclin, 'short');  % Linear Corr. 0:off, 1:linear, 2:polynomial 
fwrite(id, hdr.rdb.pclinnpts, 'short');  % fit number of points 
fwrite(id, hdr.rdb.pclinorder, 'short');  % fit order 
fwrite(id, hdr.rdb.pclinavg, 'short');  % linear phase corr avg 0:off, 1:on 
fwrite(id, hdr.rdb.pccon, 'short');  % Const Corr. 0:off, 1:Ky spec., 2:polyfit(2/ilv), 3:polyfit(1/ilv) 
fwrite(id, hdr.rdb.pcconnpts, 'short');  % fit number of points 
fwrite(id, hdr.rdb.pcconorder, 'short');  % fit order 
fwrite(id, hdr.rdb.pcextcorr, 'short');  % external correction file 0:don't use, 1: use 
fwrite(id, hdr.rdb.pcgraph, 'short');  % Phase Correction coef. image 0:off, 1:linear & constant 
fwrite(id, hdr.rdb.pcileave, 'short');  % Interleaves to use for correction: 0=all, 1=only first 
fwrite(id, hdr.rdb.hdbestky, 'short');  % bestky view for fractional Ky scan 
fwrite(id, hdr.rdb.pcctrl, 'short');  % phase correction research control 
fwrite(id, hdr.rdb.pcthrespts, 'short');  % 2..512 adjacent points 
fwrite(id, hdr.rdb.pcdiscbeg, 'short');  % 0..512 beginning point to discard 
fwrite(id, hdr.rdb.pcdiscmid, 'short');  % 0..512 middle point to discard 
fwrite(id, hdr.rdb.pcdiscend, 'short');  % 0..512 ending point to discard 
fwrite(id, hdr.rdb.pcthrespct, 'short');  % Threshold percentage 
fwrite(id, hdr.rdb.pcspacial, 'short');  % Spacial best ref scan index 0..512 
fwrite(id, hdr.rdb.pctemporal, 'short');  % Temporal best ref scan index 0..512 
fwrite(id, hdr.rdb.pcspare, 'short');  % spare for phase correction 
fwrite(id, hdr.rdb.ileaves, 'short');  % Number of interleaves 
fwrite(id, hdr.rdb.kydir, 'short');  % Ky traversal dircetion 0: top-down, 1:center out 
fwrite(id, hdr.rdb.alt, 'short');  % Alt read sign 0=no, 1=odd/even, 2=pairs 
fwrite(id, hdr.rdb.reps, 'short');  % Number of scan repetitions 
fwrite(id, hdr.rdb.ref, 'short');  % Ref Scan 0: off 1: on 
fwrite(id, hdr.rdb.pcconnorm, 'float');  % Constant S term normalization factor 
fwrite(id, hdr.rdb.pcconfitwt, 'float');  % Constant polyfit weighting factor 
fwrite(id, hdr.rdb.pclinnorm, 'float');  % Linear S term normalization factor 
fwrite(id, hdr.rdb.pclinfitwt, 'float');  % Linear polyfit weighting factor 
fwrite(id, hdr.rdb.pcbestky, 'float');  % Best Ky location 
fwrite(id, hdr.rdb.vrgf, 'int');  % control word for VRG filter 
fwrite(id, hdr.rdb.vrgfxres, 'int');  % control word for VRGF final x resolution 
fwrite(id, hdr.rdb.bp_corr, 'int');  % control word for bandpass asymmetry 
fwrite(id, hdr.rdb.recv_freq_s, 'float');  % starting frequency (+62.5) 
fwrite(id, hdr.rdb.recv_freq_e, 'float');  % ending frequency (-62.5) 
fwrite(id, hdr.rdb.hniter, 'int');  % Selects the number of (continued...)
fwrite(id, hdr.rdb.fast_rec, 'int');  % Added for homodyne II, tells if (continued...)
fwrite(id, hdr.rdb.refframes, 'int');  % total # of frames for ref scan 
fwrite(id, hdr.rdb.refframep, 'int');  % # of frames per pass for a ref scan 
fwrite(id, hdr.rdb.scnframe, 'int');  % total # of frames for a entire scan 
fwrite(id, hdr.rdb.pasframe, 'int');  % # of frames per pass 
fwrite(id, hdr.rdb.user_usage_tag, 'uint');  % for spectro 
fwrite(id, hdr.rdb.user_fill_mapMSW, 'uint');  % for spectro 
fwrite(id, hdr.rdb.user_fill_mapLSW, 'uint');  % for Spectro 
fwrite(id, hdr.rdb.user20, 'float');  % all following usercv are for spectro 
fwrite(id, hdr.rdb.user21, 'float');  
fwrite(id, hdr.rdb.user22, 'float');  
fwrite(id, hdr.rdb.user23, 'float');  
fwrite(id, hdr.rdb.user24, 'float');  
fwrite(id, hdr.rdb.user25, 'float');  
fwrite(id, hdr.rdb.user26, 'float');  
fwrite(id, hdr.rdb.user27, 'float');  
fwrite(id, hdr.rdb.user28, 'float');  
fwrite(id, hdr.rdb.user29, 'float');  
fwrite(id, hdr.rdb.user30, 'float');  
fwrite(id, hdr.rdb.user31, 'float');  
fwrite(id, hdr.rdb.user32, 'float');  
fwrite(id, hdr.rdb.user33, 'float');  
fwrite(id, hdr.rdb.user34, 'float');  
fwrite(id, hdr.rdb.user35, 'float');  
fwrite(id, hdr.rdb.user36, 'float');  
fwrite(id, hdr.rdb.user37, 'float');  
fwrite(id, hdr.rdb.user38, 'float');  
fwrite(id, hdr.rdb.user39, 'float');  
fwrite(id, hdr.rdb.user40, 'float');  
fwrite(id, hdr.rdb.user41, 'float');  
fwrite(id, hdr.rdb.user42, 'float');  
fwrite(id, hdr.rdb.user43, 'float');  
fwrite(id, hdr.rdb.user44, 'float');  
fwrite(id, hdr.rdb.user45, 'float');  
fwrite(id, hdr.rdb.user46, 'float');  
fwrite(id, hdr.rdb.user47, 'float');  
fwrite(id, hdr.rdb.user48, 'float');  
fwrite(id, hdr.rdb.pcfitorig, 'short');  % Adjust view indexes if set so bestky view = 0 
fwrite(id, hdr.rdb.pcshotfirst, 'short');  % First view within an echo group used for fit 
fwrite(id, hdr.rdb.pcshotlast, 'short');  % Last view within an echo group used for fit 
fwrite(id, hdr.rdb.pcmultegrp, 'short');  % If = 1, force pts from other egrps to be used 
fwrite(id, hdr.rdb.pclinfix, 'short');  % If = 2, force slope to be set to pclinslope 
fwrite(id, hdr.rdb.pcconfix, 'short');  % If = 2, force slope to be set to pcconslope 
fwrite(id, hdr.rdb.pclinslope, 'float');  % Value to set lin slope to if forced 
fwrite(id, hdr.rdb.pcconslope, 'float');  % Value to set con slope to if forced 
fwrite(id, hdr.rdb.pccoil, 'short');  % If 1,2,3,4, use that coil's results for all 
fwrite(id, hdr.rdb.vvsmode, 'short');  % Variable view sharing mode 
fwrite(id, hdr.rdb.vvsaimgs, 'short');  % number of original images 
fwrite(id, hdr.rdb.vvstr, 'short');  % TR in microseconds 
fwrite(id, hdr.rdb.vvsgender, 'short');  % gender: male or female 
fwrite(id, hdr.rdb.zip_factor, 'short');  % Slice ZIP factor: 0=OFF, 2, or 4 
fwrite(id, hdr.rdb.maxcoef1a, 'float');  % Coefficient A for flow image 1 
fwrite(id, hdr.rdb.maxcoef1b, 'float');  % Coefficient B for flow image 1 
fwrite(id, hdr.rdb.maxcoef1c, 'float');  % Coefficient C for flow image 1 
fwrite(id, hdr.rdb.maxcoef1d, 'float');  % Coefficient D for flow image 1 
fwrite(id, hdr.rdb.maxcoef2a, 'float');  % Coefficient A for flow image 2 
fwrite(id, hdr.rdb.maxcoef2b, 'float');  % Coefficient B for flow image 2 
fwrite(id, hdr.rdb.maxcoef2c, 'float');  % Coefficient C for flow image 2 
fwrite(id, hdr.rdb.maxcoef2d, 'float');  % Coefficient D for flow image 2 
fwrite(id, hdr.rdb.maxcoef3a, 'float');  % Coefficient A for flow image 3 
fwrite(id, hdr.rdb.maxcoef3b, 'float');  % Coefficient B for flow image 3 
fwrite(id, hdr.rdb.maxcoef3c, 'float');  % Coefficient C for flow image 3 
fwrite(id, hdr.rdb.maxcoef3d, 'float');  % Coefficient D for flow image 3 
fwrite(id, hdr.rdb.ut_ctrl, 'int');  % System utility control variable 
fwrite(id, hdr.rdb.dp_type, 'short');  % EPI II diffusion control cv 
fwrite(id, hdr.rdb.arw, 'short');  % Arrhythmia rejection window(percentage:1-100)
fwrite(id, hdr.rdb.vps, 'short');  % View Per Segment for FastCine 
fwrite(id, hdr.rdb.mcReconEnable, 'short');  % N-Coil recon map 
fwrite(id, hdr.rdb.fov, 'float');  % Auto-NCoil 
fwrite(id, hdr.rdb.te, 'int');  % TE for first echo 
fwrite(id, hdr.rdb.te2, 'int');  % TE for second and later echoes 
fwrite(id, hdr.rdb.dfmrbw, 'float');  % BW for navigator frames 
fwrite(id, hdr.rdb.dfmctrl, 'int');  % Control flag for dfm (0=off, other=on)
fwrite(id, hdr.rdb.raw_nex, 'int');  % Uncombined NEX at start of recon 
fwrite(id, hdr.rdb.navs_per_pass, 'int');  % Max. navigator frames in a pass 
fwrite(id, hdr.rdb.dfmxres, 'int');  % xres of navigator frames 
fwrite(id, hdr.rdb.dfmptsize, 'int');  % point size of navigator frames 
fwrite(id, hdr.rdb.navs_per_view, 'int');  % Num. navigators per frame (tag table) 
fwrite(id, hdr.rdb.dfmdebug, 'int');  % control flag for dfm debug 
fwrite(id, hdr.rdb.dfmthreshold, 'float');  % threshold for navigator correction 
fwrite(id, hdr.rdb.grid_control, 'short');  % bit settings controlling gridding 
fwrite(id, hdr.rdb.b0map, 'short');  % B0 map enable and map size 
fwrite(id, hdr.rdb.grid_tediff, 'short');  % TE difference between b0 map arms 
fwrite(id, hdr.rdb.grid_motion_comp, 'short');  % flag to apply motion compensation 
fwrite(id, hdr.rdb.grid_radius_a, 'float');  % variable density transition 
fwrite(id, hdr.rdb.grid_radius_b, 'float');  % variable density transition 
fwrite(id, hdr.rdb.grid_max_gradient, 'float');  % Max gradient amplitude 
fwrite(id, hdr.rdb.grid_max_slew, 'float');  % Max slew rate 
fwrite(id, hdr.rdb.grid_scan_fov, 'float');  % Rx scan field of view 
fwrite(id, hdr.rdb.grid_a2d_time, 'float');  % A to D sample time microsecs 
fwrite(id, hdr.rdb.grid_density_factor, 'float');  % change factor for variable density 
fwrite(id, hdr.rdb.grid_display_fov, 'float');  % Rx display field of view 
fwrite(id, hdr.rdb.fatwater, 'short');  % for Fat and Water Dual Recon 
fwrite(id, hdr.rdb.fiestamlf, 'short');  % MFO FIESTA recon control bit 16bits 
fwrite(id, hdr.rdb.app, 'short');  % Auto Post-Processing opcode 
fwrite(id, hdr.rdb.rhncoilsel, 'short');  % Auto-Ncoil 
fwrite(id, hdr.rdb.rhncoillimit, 'short');  % Auto-Ncoil 
fwrite(id, hdr.rdb.app_option, 'short');  % Auto Post_processing options 
fwrite(id, hdr.rdb.grad_mode, 'short');  % Gradient mode in Gemini project 
fwrite(id, hdr.rdb.pfile_passes, 'short');  % Num passes stored in a multi-pass Pfile (0 means 1 pass) 
fwrite(id, hdr.rdb.asset, 'int');  
fwrite(id, hdr.rdb.asset_calthresh, 'int');  
fwrite(id, hdr.rdb.asset_R, 'float');  
fwrite(id, hdr.rdb.coilConfigUID, 'uint');  
fwrite(id, hdr.rdb.asset_phases, 'int');  
fwrite(id, hdr.rdb.scancent, 'float');  % Table position 
fwrite(id, hdr.rdb.position, 'int');  % Patient position 
fwrite(id, hdr.rdb.entry, 'int');  % Patient entry 
fwrite(id, hdr.rdb.lmhor, 'float');  % Landmark 
fwrite(id, hdr.rdb.last_slice_num, 'int');  
fwrite(id, hdr.rdb.asset_slice_R, 'float');  % Slice reduction factor 
fwrite(id, hdr.rdb.asset_slabwrap, 'float');  
fwrite(id, hdr.rdb.dwnav_coeff, 'float');  % Coeff for amount of phase correction 
fwrite(id, hdr.rdb.dwnav_cor, 'short');  % Navigator echo correction 
fwrite(id, hdr.rdb.dwnav_view, 'short');  % Num of views of nav echoes 
fwrite(id, hdr.rdb.dwnav_corecho, 'short');  % Num of nav echoes for actual correction 
fwrite(id, hdr.rdb.dwnav_sview, 'short');  % Start view for phase correction process 
fwrite(id, hdr.rdb.dwnav_eview, 'short');  % End view for phase correction process 
fwrite(id, hdr.rdb.dwnav_sshot, 'short');  % Start shot for delta phase estimation in nav echoes 
fwrite(id, hdr.rdb.dwnav_eshot, 'short');  % End shot for delta phase estimation in nav echoes 
fwrite(id, hdr.rdb.win3d_type, 'short');  % 0 = Modified Hanning, 1 = modified Tukey 
fwrite(id, hdr.rdb.win3d_apod, 'float');  % degree of apodization; 0.0 = boxcar, 1.0=hanning 
fwrite(id, hdr.rdb.win3d_q, 'float');  % apodization at ends, 0.0 = max, 1.0 = boxcar 
fwrite(id, hdr.rdb.ime_scic_enable, 'short');  % Surface Coil Intensity Correction: 1 if enabled 
fwrite(id, hdr.rdb.clariview_type, 'short');  % Type of Clariview/Name of Filter 
fwrite(id, hdr.rdb.ime_scic_edge, 'float');  % Edge paramaters for Enhanced Recon 
fwrite(id, hdr.rdb.ime_scic_smooth, 'float');  % Smooth paramaters for Enhanced Recon 
fwrite(id, hdr.rdb.ime_scic_focus, 'float');  % Focus paramaters for Enhanced Recon 
fwrite(id, hdr.rdb.clariview_edge, 'float');  % Edge paramaters for clariview 
fwrite(id, hdr.rdb.clariview_smooth, 'float');  % Smooth paramaters for clariview 
fwrite(id, hdr.rdb.clariview_focus, 'float');  % Focus paramaters for clariview 
fwrite(id, hdr.rdb.scic_reduction, 'float');  % Reduction paramater for SCIC 
fwrite(id, hdr.rdb.scic_gauss, 'float');  % Gauss paramater for SCIC 
fwrite(id, hdr.rdb.scic_threshold, 'float');  % Threshold paramater for SCIC 
fwrite(id, hdr.rdb.ectricks_no_regions, 'int');  % Total no of regions acquired by PSD 
fwrite(id, hdr.rdb.ectricks_input_regions, 'int');  % Total no of input regions for reordering 
fwrite(id, hdr.rdb.psc_reuse, 'short');  % Header field for smart prescan 
fwrite(id, hdr.rdb.left_blank, 'short');  
fwrite(id, hdr.rdb.right_blank, 'short');  
fwrite(id, hdr.rdb.acquire_type, 'short');  % Acquire type information from CV 
fwrite(id, hdr.rdb.retro_control, 'short');  % Retrosective FSE phase correction control flag. (continued...)
fwrite(id, hdr.rdb.etl, 'short');  % Added for Retrospective FSE phase correction. This (continued...)
fwrite(id, hdr.rdb.pcref_start, 'short');  % 1st view to use for dynamic EPI phase correction. 
fwrite(id, hdr.rdb.pcref_stop, 'short');  % Last view to use for dynamic EPI phase correction. 
fwrite(id, hdr.rdb.ref_skip, 'short');  % Number of passes to skip for dynamic EPI phase correction. 
fwrite(id, hdr.rdb.extra_frames_top, 'short');  % Number of extra frames at top of K-space 
fwrite(id, hdr.rdb.extra_frames_bot, 'short');  % Number of extra frames at bottom of K-space 
fwrite(id, hdr.rdb.multiphase_type, 'short');  % 0 = INTERLEAVED , 1 = SEQUENTIAL 
fwrite(id, hdr.rdb.nphases, 'short');  % Number of phases in a multiphase scan 
fwrite(id, hdr.rdb.pure, 'short');  % PURE flag from psd 
fwrite(id, hdr.rdb.pure_scale, 'float');  % Recon scale factor ratio for cal scan 
fwrite(id, hdr.rdb.off_data, 'int');  % Byte offset to start of raw data (i.e size of POOL_HEADER) 
fwrite(id, hdr.rdb.off_per_pass, 'int');  % Byte offset to start of rdb_hdr_per_pass of POOL_HEADER 
fwrite(id, hdr.rdb.off_unlock_raw, 'int');  % Byte offset to start of rdb_hdr_unlock_raw of POOL_HEADER 
fwrite(id, hdr.rdb.off_data_acq_tab, 'int');  % Byte offset to start of rdb_hdr_data_acq_tab of POOL_HEADER 
fwrite(id, hdr.rdb.off_nex_tab, 'int');  % Byte offset to start of rdb_hdr_nex_tab of POOL_HEADER 
fwrite(id, hdr.rdb.off_nex_abort_tab, 'int');  % Byte offset to start of rdb_hdr_nex_abort_tab of POOL_HEADER 
fwrite(id, hdr.rdb.off_tool, 'int');  % Byte offset to start of rdb_hdr_tool of POOL_HEADER 
fwrite(id, hdr.rdb.off_exam, 'int');  % Byte offset to start of rdb_hdr_exam of POOL_HEADER 
fwrite(id, hdr.rdb.off_series, 'int');  % Byte offset to start of rdb_hdr_series of POOL_HEADER 
fwrite(id, hdr.rdb.off_image, 'int');  % Byte offset to start of rdb_hdr_image of POOL_HEADER 
fwrite(id, hdr.rdb.off_ps, 'int');  % Byte offset to start of rdb_hdr_ps of POOL_HEADER 
fwrite(id, hdr.rdb.off_spare_b, 'int');  % spare 
fwrite(id, hdr.rdb.new_wnd_level_flag, 'int');  % New WW/WL algo enable/disable flag 
fwrite(id, hdr.rdb.wnd_image_hist_area, 'int');  % Image Area % 
fwrite(id, hdr.rdb.wnd_high_hist, 'float');  % Histogram Area Top 
fwrite(id, hdr.rdb.wnd_lower_hist, 'float');  % Histogram Area Bottom 
fwrite(id, hdr.rdb.pure_filter, 'short');  % PURE noise reduction on=1/off=0 
fwrite(id, hdr.rdb.cfg_pure_filter, 'short');  % PURE cfg file value 
fwrite(id, hdr.rdb.cfg_pure_fit_order, 'short');  % PURE cfg file value 
fwrite(id, hdr.rdb.cfg_pure_kernelsize_z, 'short');  % PURE cfg file value 
fwrite(id, hdr.rdb.cfg_pure_kernelsize_xy, 'short');  % PURE cfg file value 
fwrite(id, hdr.rdb.cfg_pure_weight_radius, 'short');  % PURE cfg file value 
fwrite(id, hdr.rdb.cfg_pure_intensity_scale, 'short');  % PURE cfg file value 
fwrite(id, hdr.rdb.cfg_pure_noise_threshold, 'short');  % PURE cfg file value 
fwrite(id, hdr.rdb.wienera, 'float');  % NB maintain alignment of floats 
fwrite(id, hdr.rdb.wienerb, 'float');  
fwrite(id, hdr.rdb.wienert2, 'float');  
fwrite(id, hdr.rdb.wieneresp, 'float');  
fwrite(id, hdr.rdb.wiener, 'short');  
fwrite(id, hdr.rdb.flipfilter, 'short');  
fwrite(id, hdr.rdb.dbgrecon, 'short');  
fwrite(id, hdr.rdb.ech2skip, 'short');  
fwrite(id, hdr.rdb.tricks_type, 'int');  % 0 = Subtracted, 1 = Unsubtracted 
fwrite(id, hdr.rdb.lcfiesta_phase, 'float');  % LC Fiesta 
fwrite(id, hdr.rdb.lcfiesta, 'short');  % LC Fiesta 
fwrite(id, hdr.rdb.herawflt, 'short');  % Half echo raw data filter 
fwrite(id, hdr.rdb.herawflt_befnwin, 'short');  % Half echo raw data filter 
fwrite(id, hdr.rdb.herawflt_befntran, 'short');  % Half echo raw data filter 
fwrite(id, hdr.rdb.herawflt_befamp, 'float');  % Half echo raw data filter 
fwrite(id, hdr.rdb.herawflt_hpfamp, 'float');  % Half echo raw data filter 
fwrite(id, hdr.rdb.heover, 'short');  % Half echo over sampling 
fwrite(id, hdr.rdb.pure_correction_threshold, 'short');  % PURE Correction threshold 
fwrite(id, hdr.rdb.swiftenable, 'int');  % SWIFT enable/disable flag 
fwrite(id, hdr.rdb.numslabs, 'short');  % Number of slabs to be used by TRICKS 
fwrite(id, hdr.rdb.numCoilConfigs, 'ushort');  % Number of coils to SWIFT between 
fwrite(id, hdr.rdb.ps_autoshim_status, 'int');  
fwrite(id, hdr.rdb.dynaplan_numphases, 'int');  % Number of phases for Dynamic Plan 
fwrite(id, hdr.rdb.medal_cfg, 'short');  % MEDAL configuration bitmask 
fwrite(id, hdr.rdb.medal_nstack, 'short');  % MEDAL pixel stack size 
fwrite(id, hdr.rdb.medal_echo_order, 'short');  % MEDAL in-phase, out-of-phase order
fwrite(id, hdr.rdb.medal_kernel_up, 'short');  % MEDAL max adaptive region (continued...)
fwrite(id, hdr.rdb.medal_kernel_down, 'short');  % MEDAL min adaptive region (continued...)
fwrite(id, hdr.rdb.medal_kernel_smooth, 'short');  % MEDAL field smoothing (continued...)
fwrite(id, hdr.rdb.medal_start, 'short');  % MEDAL 2D region growing (continued...)
fwrite(id, hdr.rdb.medal_end, 'short');  % MEDAL 2D region growing (continued...)
fwrite(id, hdr.rdb.rcideal, 'uint');  % Enable/Disable flag 
fwrite(id, hdr.rdb.rcdixproc, 'uint');  % IDEAL image options and IDEAL control bits 
fwrite(id, hdr.rdb.df, 'float');  % Delta Frequency between two species 
fwrite(id, hdr.rdb.bw, 'float');  % Bandwidth in hz 
fwrite(id, hdr.rdb.te1, 'float');  % First Echo time in ms 
fwrite(id, hdr.rdb.esp, 'float');  % Echo spacing in ms 
fwrite(id, hdr.rdb.feextra, 'int');  % This will give the number of extra points 
fwrite(id, hdr.rdb.raw_pass_size, 'uint64');  
fwrite(id, hdr.rdb.sspsave, 'uint64');  
fwrite(id, hdr.rdb.udasave, 'uint64');  
fwrite(id, hdr.rdb.vibrant, 'short');  % Set to 1 for VIBRANT scans 
fwrite(id, hdr.rdb.asset_torso, 'short');  % Set to 1 for torso scans 
fwrite(id, hdr.rdb.asset_alt_cal, 'int');  % Set to 1 to use reapodized cal 
fwrite(id, hdr.rdb.kacq_uid, 'int');  % unique id for kacq_yz.txt files 
for itrans=[1:length(hdr.rdb.cttEntry)]  % kluge for type ChannelTransTableEntryType
  fwrite(id, hdr.rdb.cttEntry(itrans).logicalCoilName, 'int8');  % The logicalCoilName of Active Coil
  fwrite(id, hdr.rdb.cttEntry(itrans).clinicalCoilName, 'int8');  % The clinicalCoilName of Active Coil
  fwrite(id, hdr.rdb.cttEntry(itrans).configUID, 'uint32');  % A unique identifier based on coil parameters
  fwrite(id, hdr.rdb.cttEntry(itrans).coilConnector, 'int32');  % The coilConnector to which Active Coil is connected
  fwrite(id, hdr.rdb.cttEntry(itrans).isActiveScanConfig, 'uint32');  % Indicates whether this config is used for active scanning
  fwrite(id, hdr.rdb.cttEntry(itrans).channelTranslationMap, 'int16');  % The channel translation map for this config
end
fwrite(id, hdr.rdb.psc_ta, 'int32');  
fwrite(id, hdr.rdb.disk_acq_ctrl, 'int32');  % rhdiskacqctrl control 
fwrite(id, hdr.rdb.asset_localTx, 'int');  % Set to 1 for local Tx phased arrays 
fwrite(id, hdr.rdb.scale3d, 'float');  % Use to scale 3D acqs to avoid overrange 
fwrite(id, hdr.rdb.broad_band_select, 'int');  % Set to 1 for Broadband exciter, Set to 0 for NarrowBand exciter 
fwrite(id, hdr.rdb.scanner_mode, 'short');  % 1=Product, 2=Research, 3=Service 
fwrite(id, hdr.rdb.numbvals, 'short');  % Total number of b values for Multi-b DWI 
fwrite(id, hdr.rdb.numdifdirs, 'short');  % Number of diffusion directions. 1: Single 3: Three 4: Tetrahedral 
fwrite(id, hdr.rdb.difnext2, 'short');  % Image-based NEX number for T2 (Smart nex) 
fwrite(id, hdr.rdb.difnextab, 'short');  % Multi-b eDWI: NEX number for each b-value 
fwrite(id, hdr.rdb.channel_combine_method, 'short');  % Set to RDB_COMPLEX_COMBINE for complex channel combine recon 
fwrite(id, hdr.rdb.nexForUnacquiredEncodes, 'short');  % Used for filling NEX table for unacquired encodes 
fwrite(id, hdr.rdb.excess, 'short');  % free space for later expansion 
fwrite(id, hdr.per_pass, 'uint64');  % lumped type RDB_PER_PASS_TAB
fwrite(id, hdr.unlock_raw, 'uint64');  % lumped type RDB_PER_PASS_TAB
for islice=[1:length(hdr.data_acq_tab)]  % kluge for type RDB_SLICE_INFO_ENTRY
  fwrite(id, hdr.data_acq_tab(islice).pass_number, 'short');  % which pass this slice is in
  fwrite(id, hdr.data_acq_tab(islice).slice_in_pass, 'short');  % which slice in this pass
  fwrite(id, hdr.data_acq_tab(islice).gw_point, 'float');  % corner points of image
  fwrite(id, hdr.data_acq_tab(islice).transpose, 'short');  % The transpose value for every slice
  fwrite(id, hdr.data_acq_tab(islice).rotate, 'short');  % The rotate value for every slice
  fwrite(id, hdr.data_acq_tab(islice).coilConfigUID, 'uint');  % Coil to be used by ASSET for SWIFT type of scans
end
fwrite(id, hdr.nex_tab, 'char');  % lumped type RDB_NEX_TYPE
fwrite(id, hdr.nex_abort_tab, 'char');  % lumped type RDB_NEX_TYPE
fwrite(id, hdr.tool, 'char');  % lumped type TOOLSDATA
fwrite(id, hdr.ps.command, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.mps_r1, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.mps_r2, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.mps_tg, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.mps_freq, 'uint32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.aps_r1, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.aps_r2, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.aps_tg, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.aps_freq, 'uint32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.scalei, 'float');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.scaleq, 'float');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.snr_warning, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.aps_or_mps, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.mps_bitmap, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.powerspec, 'int8');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.filler1, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.filler2, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.xshim, 'int16');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.yshim, 'int16');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.zshim, 'int16');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.recon_enable, 'int16');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.autoshim_status, 'int32');  % to determine whether autoshim was performed or not(smart/OFF)
fwrite(id, hdr.ps.rec_std, 'float');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.rec_mean, 'float');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.line_width, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.ws_flip, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.supp_lvl, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.psc_reuse, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.psc_reuse_string, 'char');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.psc_ta, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.phase_correction_status, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.broad_band_select, 'int32');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.ps.buffer, 'char');  % kluge for type PRESCAN_HEADER
fwrite(id, hdr.exam.firstaxtime, 'double');  % Start time(secs) of first axial in exam
fwrite(id, hdr.exam.double_padding, 'double');  % Please use this if you are adding any doubles
fwrite(id, hdr.exam.zerocell, 'float');  % Cell number at theta
fwrite(id, hdr.exam.cellspace, 'float');  % Cell spacing
fwrite(id, hdr.exam.srctodet, 'float');  % Distance from source to detector
fwrite(id, hdr.exam.srctoiso, 'float');  % Distance from source to iso
fwrite(id, hdr.exam.float_padding, 'float');  % Please use this if you are adding any floats
fwrite(id, hdr.exam.ex_delta_cnt, 'int');  % Indicates number of updates to header
fwrite(id, hdr.exam.ex_complete, 'int');  % Exam Complete Flag
fwrite(id, hdr.exam.ex_seriesct, 'int');  % Last Series Number Used
fwrite(id, hdr.exam.ex_numarch, 'int');  % Number of Series Archived
fwrite(id, hdr.exam.ex_numseries, 'int');  % Number of Series Existing
fwrite(id, hdr.exam.ex_numunser, 'int');  % Number of Unstored Series
fwrite(id, hdr.exam.ex_toarchcnt, 'int');  % Number of Unarchived Series
fwrite(id, hdr.exam.ex_prospcnt, 'int');  % Number of Prospective/Scout Series
fwrite(id, hdr.exam.ex_modelnum, 'int');  % Last Model Number used
fwrite(id, hdr.exam.ex_modelcnt, 'int');  % Number of ThreeD Models
fwrite(id, hdr.exam.int_padding1, 'int');  % Please use this if you are adding any ints
fwrite(id, hdr.exam.numcells, 'int');  % Number of cells in det
fwrite(id, hdr.exam.magstrength, 'int');  % Magnet strength (in gauss)
fwrite(id, hdr.exam.patweight, 'int');  % Patient Weight
fwrite(id, hdr.exam.ex_datetime, 'int');  % Exam date/time stamp
fwrite(id, hdr.exam.ex_lastmod, 'int');  % Date/Time of Last Change
fwrite(id, hdr.exam.int_padding2, 'int');  % Please use this if you are adding any ints
fwrite(id, hdr.exam.ex_no, 'ushort');  % Exam Number
fwrite(id, hdr.exam.ex_uniq, 'short');  % The Make-Unique Flag
fwrite(id, hdr.exam.detect, 'short');  % Detector Type
fwrite(id, hdr.exam.tubetyp, 'short');  % Tube type
fwrite(id, hdr.exam.dastyp, 'short');  % DAS type
fwrite(id, hdr.exam.num_dcnk, 'short');  % Number of Decon Kernals
fwrite(id, hdr.exam.dcn_len, 'short');  % Number of elements in a Decon Kernal
fwrite(id, hdr.exam.dcn_density, 'short');  % Decon Kernal density
fwrite(id, hdr.exam.dcn_stepsize, 'short');  % Decon Kernal stepsize
fwrite(id, hdr.exam.dcn_shiftcnt, 'short');  % Decon Kernal Shift Count
fwrite(id, hdr.exam.patage, 'short');  % Patient Age (years, months or days)
fwrite(id, hdr.exam.patian, 'short');  % Patient Age Notation
fwrite(id, hdr.exam.patsex, 'short');  % Patient Sex
fwrite(id, hdr.exam.ex_format, 'short');  % Exam Format
fwrite(id, hdr.exam.trauma, 'short');  % Trauma Flag
fwrite(id, hdr.exam.protocolflag, 'short');  % Non-Zero indicates Protocol Exam
fwrite(id, hdr.exam.study_status, 'short');  % indicates if study has complete info(DICOM/genesis)
fwrite(id, hdr.exam.short_padding, 'short');  % Please use this if you are adding any shorts
fwrite(id, hdr.exam.hist, 'char');  % Patient History
fwrite(id, hdr.exam.refphy, 'char');  % Referring Physician
fwrite(id, hdr.exam.diagrad, 'char');  % Diagnostician/Radiologist
fwrite(id, hdr.exam.operator_new, 'char');  
fwrite(id, hdr.exam.ex_desc, 'char');  % Exam Description
fwrite(id, hdr.exam.ex_typ, 'char');  % Exam Type
fwrite(id, hdr.exam.ex_sysid, 'char');  % Creator Suite and Host
fwrite(id, hdr.exam.ex_alloc_key, 'char');  % Process that allocated this record
fwrite(id, hdr.exam.ex_diskid, 'char');  % Disk ID for this Exam
fwrite(id, hdr.exam.hospname, 'char');  % Hospital Name
fwrite(id, hdr.exam.ex_suid, 'char');  % Suite ID for this Exam
fwrite(id, hdr.exam.ex_verscre, 'char');  % Genesis Version - Created
fwrite(id, hdr.exam.ex_verscur, 'char');  % Genesis Version - Now
fwrite(id, hdr.exam.uniq_sys_id, 'char');  % Unique System ID
fwrite(id, hdr.exam.service_id, 'char');  % Unique Service ID
fwrite(id, hdr.exam.mobile_loc, 'char');  % Mobile Location Number
fwrite(id, hdr.exam.study_uid, 'char');  % Study Entity Unique ID
fwrite(id, hdr.exam.refsopcuid, 'char');  % Ref SOP Class UID 
fwrite(id, hdr.exam.refsopiuid, 'char');  % Ref SOP Instance UID 
fwrite(id, hdr.exam.patnameff, 'char');  % FF Patient Name 
fwrite(id, hdr.exam.patidff, 'char');  % FF Patient ID 
fwrite(id, hdr.exam.reqnumff, 'char');  % FF Requisition No 
fwrite(id, hdr.exam.dateofbirth, 'char');  % Date of Birth 
fwrite(id, hdr.exam.mwlstudyuid, 'char');  % Genesis Exam UID 
fwrite(id, hdr.exam.mwlstudyid, 'char');  % Genesis Exam No 
fwrite(id, hdr.exam.ex_padding, 'char');  % Spare Space only for BLOCKs
fwrite(id, hdr.series.double_padding, 'double');  % Please use this if you are adding any doubles
fwrite(id, hdr.series.se_pds_a, 'float');  % PixelData size - as stored
fwrite(id, hdr.series.se_pds_c, 'float');  % PixelData size - Compressed
fwrite(id, hdr.series.se_pds_u, 'float');  % PixelData size - UnCompressed
fwrite(id, hdr.series.lmhor, 'float');  % Horizontal Landmark
fwrite(id, hdr.series.start_loc, 'float');  % First scan location (L/S)
fwrite(id, hdr.series.end_loc, 'float');  % Last scan location (L/S)
fwrite(id, hdr.series.echo1_alpha, 'float');  % Echo 1 Alpha Value
fwrite(id, hdr.series.echo1_beta, 'float');  % Echo 1 Beta Value
fwrite(id, hdr.series.echo2_alpha, 'float');  % Echo 2 Alpha Value
fwrite(id, hdr.series.echo2_beta, 'float');  % Echo 2 Beta Value
fwrite(id, hdr.series.echo3_alpha, 'float');  % Echo 3 Alpha Value
fwrite(id, hdr.series.echo3_beta, 'float');  % Echo 3 Beta Value
fwrite(id, hdr.series.echo4_alpha, 'float');  % Echo 4 Alpha Value
fwrite(id, hdr.series.echo4_beta, 'float');  % Echo 4 Beta Value
fwrite(id, hdr.series.echo5_alpha, 'float');  % Echo 5 Alpha Value
fwrite(id, hdr.series.echo5_beta, 'float');  % Echo 5 Beta Value
fwrite(id, hdr.series.echo6_alpha, 'float');  % Echo 6 Alpha Value
fwrite(id, hdr.series.echo6_beta, 'float');  % Echo 6 Beta Value
fwrite(id, hdr.series.echo7_alpha, 'float');  % Echo 7 Alpha Value
fwrite(id, hdr.series.echo7_beta, 'float');  % Echo 7 Beta Value
fwrite(id, hdr.series.echo8_alpha, 'float');  % Echo 8 Alpha Value
fwrite(id, hdr.series.echo8_beta, 'float');  % Echo 8 Beta Value
fwrite(id, hdr.series.float_padding, 'float');  % Please use this if you are adding any floats
fwrite(id, hdr.series.se_complete, 'int');  % Series Complete Flag
fwrite(id, hdr.series.se_numarch, 'int');  % Number of Images Archived
fwrite(id, hdr.series.se_imagect, 'int');  % Last Image Number Used
fwrite(id, hdr.series.se_numimages, 'int');  % Number of Images Existing
fwrite(id, hdr.series.se_delta_cnt, 'int');  % Indicates number of updates to header
fwrite(id, hdr.series.se_numunimg, 'int');  % Number of Unstored Images
fwrite(id, hdr.series.se_toarchcnt, 'int');  % Number of Unarchived Images
fwrite(id, hdr.series.int_padding1, 'int');  % Please use this if you are adding any longs
fwrite(id, hdr.series.se_datetime, 'int');  % Allocation Series Data/Time stamp
fwrite(id, hdr.series.se_actual_dt, 'int');  % Actual Series Data/Time stamp
fwrite(id, hdr.series.position, 'int');  % Patient Position
fwrite(id, hdr.series.entry, 'int');  % Patient Entry
fwrite(id, hdr.series.se_lndmrkcnt, 'int');  % Landmark Counter
fwrite(id, hdr.series.se_lastmod, 'int');  % Date/Time of Last Change
fwrite(id, hdr.series.ExpType, 'int');  
fwrite(id, hdr.series.TrRest, 'int');  
fwrite(id, hdr.series.TrActive, 'int');  
fwrite(id, hdr.series.DumAcq, 'int');  
fwrite(id, hdr.series.ExptTimePts, 'int');  
fwrite(id, hdr.series.int_padding2, 'int');  % Please use this if you are adding any ints
fwrite(id, hdr.series.se_exno, 'ushort');  % Exam Number
fwrite(id, hdr.series.echo1_window, 'ushort');  % Echo 1 Window Value
fwrite(id, hdr.series.echo2_window, 'ushort');  % Echo 2 Window Value
fwrite(id, hdr.series.echo3_window, 'ushort');  % Echo 3 Window Value
fwrite(id, hdr.series.echo4_window, 'ushort');  % Echo 4 Window Value
fwrite(id, hdr.series.echo5_window, 'ushort');  % Echo 5 Window Value
fwrite(id, hdr.series.echo6_window, 'ushort');  % Echo 6 Window Value
fwrite(id, hdr.series.echo7_window, 'ushort');  % Echo 7 Window Value
fwrite(id, hdr.series.echo8_window, 'ushort');  % Echo 8 Window Value
fwrite(id, hdr.series.echo8_level, 'short');  % Echo 8 Level Value
fwrite(id, hdr.series.echo7_level, 'short');  % Echo 7 Level Value
fwrite(id, hdr.series.echo6_level, 'short');  % Echo 6 Level Value
fwrite(id, hdr.series.echo5_level, 'short');  % Echo 5 Level Value
fwrite(id, hdr.series.echo4_level, 'short');  % Echo 4 Level Value
fwrite(id, hdr.series.echo3_level, 'short');  % Echo 3 Level Value
fwrite(id, hdr.series.echo2_level, 'short');  % Echo 2 Level Value
fwrite(id, hdr.series.echo1_level, 'short');  % Echo 1 Level Value
fwrite(id, hdr.series.se_no, 'short');  % Series Number
fwrite(id, hdr.series.se_typ, 'short');  % Series Type
fwrite(id, hdr.series.se_source, 'short');  % Series from which prescribed
fwrite(id, hdr.series.se_plane, 'short');  % Most-like Plane (for L/S)
fwrite(id, hdr.series.scan_type, 'short');  % Scout or Axial (for CT)
fwrite(id, hdr.series.se_uniq, 'short');  % The Make-Unique Flag
fwrite(id, hdr.series.se_contrast, 'short');  % Non-zero if > 0 image used contrast(L/S)
fwrite(id, hdr.series.se_pseq, 'short');  % Last Pulse Sequence Used (L/S)
fwrite(id, hdr.series.se_sortorder, 'short');  % Image Sort Order (L/S)
fwrite(id, hdr.series.se_nacq, 'short');  % Number of Acquisitions
fwrite(id, hdr.series.xbasest, 'short');  % Starting number for baselines
fwrite(id, hdr.series.xbaseend, 'short');  % Ending number for baselines
fwrite(id, hdr.series.xenhst, 'short');  % Starting number for enhanced scans
fwrite(id, hdr.series.xenhend, 'short');  % Ending number for enhanced scans
fwrite(id, hdr.series.table_entry, 'short');  % Table position for nMR and iMR
fwrite(id, hdr.series.SwingAngle, 'short');  % nMR - Swing Angle
fwrite(id, hdr.series.LateralOffset, 'short');  % nMR - Offset
fwrite(id, hdr.series.GradientCoil, 'short');  % Gradient Coil Selection 
fwrite(id, hdr.series.se_subtype, 'short');  % supplements se_typ, see DICOM (0008,0008) //GSAge04506 
fwrite(id, hdr.series.BWRT, 'short');  % for fMRI till ExptTimePts 
fwrite(id, hdr.series.assetcal_serno, 'short');  % Calibration Series number 
fwrite(id, hdr.series.assetcal_scnno, 'short');  % Calibration Scan number
fwrite(id, hdr.series.content_qualifn, 'short');  % PRODUCT/RESEARCH/SERVICE
fwrite(id, hdr.series.purecal_serno, 'short');  % Calibration Series number
fwrite(id, hdr.series.purecal_scnno, 'short');  % Calibration Scan number
fwrite(id, hdr.series.ideal, 'short');  % Water, FAT, In-Phase and Out-Phase
fwrite(id, hdr.series.short_padding, 'short');  % Please use this if you are adding any shots
fwrite(id, hdr.series.se_verscre, 'char');  % Genesis Version - Created
fwrite(id, hdr.series.se_verscur, 'char');  % Genesis Version - Now
fwrite(id, hdr.series.se_suid, 'char');  % Suite ID for this Series
fwrite(id, hdr.series.se_alloc_key, 'char');  % Process that allocated this record
fwrite(id, hdr.series.se_diskid, 'char');  % Disk ID for this Series
fwrite(id, hdr.series.se_desc, 'char');  % Series Description
fwrite(id, hdr.series.pr_sysid, 'char');  % Primary Receiver Suite and Host
fwrite(id, hdr.series.pansysid, 'char');  % Archiver Suite and Host
fwrite(id, hdr.series.anref, 'char');  % Anatomical reference
fwrite(id, hdr.series.prtcl, 'char');  % Scan Protocol Name
fwrite(id, hdr.series.start_ras, 'char');  % RAS letter for first scan location (L/S)
fwrite(id, hdr.series.end_ras, 'char');  % RAS letter for last scan location (L/S)
fwrite(id, hdr.series.series_uid, 'char');  % Series Entity Unique ID
fwrite(id, hdr.series.landmark_uid, 'char');  % Landmark Unique ID
fwrite(id, hdr.series.equipmnt_uid, 'char');  % Equipment Unique ID
fwrite(id, hdr.series.refsopcuids, 'char');  % Ref SOP Class UID 
fwrite(id, hdr.series.refsopiuids, 'char');  % Ref SOP Instance UID 
fwrite(id, hdr.series.schacitval, 'char');  % Sched Proc Action Item Seq - Value 
fwrite(id, hdr.series.schacitdesc, 'char');  % Sched Proc Action Item Seq - Description 
fwrite(id, hdr.series.schacitmea, 'char');  % Sched Proc Action Item Seq - Meaning 
fwrite(id, hdr.series.schprocstdesc, 'char');  % Sched Proc Step Desc 
fwrite(id, hdr.series.schprocstid, 'char');  % Sched Proc Step ID 1
fwrite(id, hdr.series.reqprocstid, 'char');  % Req Proc Step ID 1
fwrite(id, hdr.series.perprocstid, 'char');  % PPS ID 
fwrite(id, hdr.series.perprocstdesc, 'char');  % PPS Description
fwrite(id, hdr.series.reqprocstid2, 'char');  % Req Proc Step ID 2
fwrite(id, hdr.series.reqprocstid3, 'char');  % Req Proc Step ID 3
fwrite(id, hdr.series.schprocstid2, 'char');  % Sched Proc Step ID 2
fwrite(id, hdr.series.schprocstid3, 'char');  % Sched Proc Step ID 3
fwrite(id, hdr.series.refImgUID, 'char');  % Dicom Reference Image 
fwrite(id, hdr.series.PdgmStr, 'char');  
fwrite(id, hdr.series.PdgmDesc, 'char');  
fwrite(id, hdr.series.PdgmUID, 'char');  
fwrite(id, hdr.series.ApplName, 'char');  
fwrite(id, hdr.series.ApplVer, 'char');  
fwrite(id, hdr.series.asset_appl, 'char');  % Asset application name
fwrite(id, hdr.series.scic_a, 'char');  % Scic_a values from CoilConfig.cfg
fwrite(id, hdr.series.scic_s, 'char');  % Scic_s values from CoilConfig.cfg
fwrite(id, hdr.series.scic_c, 'char');  % Scic_c values from CoilConfig.cfg
fwrite(id, hdr.series.pure_cfg_params, 'char');  % PURE Config Parameters from pure.cfg 
fwrite(id, hdr.series.se_padding, 'char');  % Spare Space
fwrite(id, hdr.image.autoSubParam, 'char');  % kluge for type AutoSubParam
fwrite(id, hdr.image.double_padding, 'double');  % Please use this if you are adding any doubles
fwrite(id, hdr.image.dfov, 'float');  % Display field of view - X (mm)
fwrite(id, hdr.image.dfov_rect, 'float');  % Display field of view - Y (if different)
fwrite(id, hdr.image.sctime, 'float');  % Duration of scan
fwrite(id, hdr.image.slthick, 'float');  % Slice Thickness (mm)
fwrite(id, hdr.image.scanspacing, 'float');  % Spacing between scans (mm?)
fwrite(id, hdr.image.loc, 'float');  % Image location
fwrite(id, hdr.image.tbldlta, 'float');  % Table Delta
fwrite(id, hdr.image.nex, 'float');  % Number of Excitations
fwrite(id, hdr.image.reptime, 'float');  % Cardiac repetition time
fwrite(id, hdr.image.saravg, 'float');  % Average SAR
fwrite(id, hdr.image.sarpeak, 'float');  % Peak SAR
fwrite(id, hdr.image.pausetime, 'float');  % Pause Time
fwrite(id, hdr.image.vbw, 'float');  % Variable Bandwidth (Hz)
fwrite(id, hdr.image.user0, 'float');  % User Variable 0
fwrite(id, hdr.image.user1, 'float');  % User Variable 1
fwrite(id, hdr.image.user2, 'float');  % User Variable 2
fwrite(id, hdr.image.user3, 'float');  % User Variable 3
fwrite(id, hdr.image.user4, 'float');  % User Variable 4
fwrite(id, hdr.image.user5, 'float');  % User Variable 5
fwrite(id, hdr.image.user6, 'float');  % User Variable 6
fwrite(id, hdr.image.user7, 'float');  % User Variable 7
fwrite(id, hdr.image.user8, 'float');  % User Variable 8
fwrite(id, hdr.image.user9, 'float');  % User Variable 9
fwrite(id, hdr.image.user10, 'float');  % User Variable 10
fwrite(id, hdr.image.user11, 'float');  % User Variable 11
fwrite(id, hdr.image.user12, 'float');  % User Variable 12
fwrite(id, hdr.image.user13, 'float');  % User Variable 13
fwrite(id, hdr.image.user14, 'float');  % User Variable 14
fwrite(id, hdr.image.user15, 'float');  % User Variable 15
fwrite(id, hdr.image.user16, 'float');  % User Variable 16
fwrite(id, hdr.image.user17, 'float');  % User Variable 17
fwrite(id, hdr.image.user18, 'float');  % User Variable 18
fwrite(id, hdr.image.user19, 'float');  % User Variable 19
fwrite(id, hdr.image.user20, 'float');  % User Variable 20
fwrite(id, hdr.image.user21, 'float');  % User Variable 21
fwrite(id, hdr.image.user22, 'float');  % User Variable 22
fwrite(id, hdr.image.proj_ang, 'float');  % Projection Angle
fwrite(id, hdr.image.concat_sat, 'float');  % Concat Sat Type Flag
fwrite(id, hdr.image.user23, 'float');  % User Variable 23
fwrite(id, hdr.image.user24, 'float');  % User Variable 24
fwrite(id, hdr.image.x_axis_rot, 'float');  % X Axis Rotation
fwrite(id, hdr.image.y_axis_rot, 'float');  % Y Axis Rotation
fwrite(id, hdr.image.z_axis_rot, 'float');  % Z Axis Rotation
fwrite(id, hdr.image.ihtagfa, 'float');  % Tagging Flip Angle
fwrite(id, hdr.image.ihtagor, 'float');  % Cardiac Tagging Orientation
fwrite(id, hdr.image.ihbspti, 'float');  % Blood Suppression TI
fwrite(id, hdr.image.rtia_timer, 'float');  % Float Slop Field 4
fwrite(id, hdr.image.fps, 'float');  % Float Slop Field 5
fwrite(id, hdr.image.vencscale, 'float');  % Scale Weighted Venc
fwrite(id, hdr.image.dbdt, 'float');  % peak rate of change of gradient field, tesla/sec
fwrite(id, hdr.image.dbdtper, 'float');  % limit in units of percent of theoretical curve
fwrite(id, hdr.image.estdbdtper, 'float');  % PSD estimated limit in units of percent
fwrite(id, hdr.image.estdbdtts, 'float');  % PSD estimated limit in Teslas/sec
fwrite(id, hdr.image.saravghead, 'float');  % Avg head SAR
fwrite(id, hdr.image.neg_scanspacing, 'float');  % Negative scan spacing for overlap slices
fwrite(id, hdr.image.user25, 'float');  % User Variable 25
fwrite(id, hdr.image.user26, 'float');  % User Variable 26
fwrite(id, hdr.image.user27, 'float');  % User Variable 27
fwrite(id, hdr.image.user28, 'float');  % User Variable 28
fwrite(id, hdr.image.user29, 'float');  % User Variable 29
fwrite(id, hdr.image.user30, 'float');  % User Variable 30
fwrite(id, hdr.image.user31, 'float');  % User Variable 31
fwrite(id, hdr.image.user32, 'float');  % User Variable 32
fwrite(id, hdr.image.user33, 'float');  % User Variable 33
fwrite(id, hdr.image.user34, 'float');  % User Variable 34
fwrite(id, hdr.image.user35, 'float');  % User Variable 35
fwrite(id, hdr.image.user36, 'float');  % User Variable 36
fwrite(id, hdr.image.user37, 'float');  % User Variable 37
fwrite(id, hdr.image.user38, 'float');  % User Variable 38
fwrite(id, hdr.image.user39, 'float');  % User Variable 39
fwrite(id, hdr.image.user40, 'float');  % User Variable 40
fwrite(id, hdr.image.user41, 'float');  % User Variable 41
fwrite(id, hdr.image.user42, 'float');  % User Variable 42
fwrite(id, hdr.image.user43, 'float');  % User Variable 43
fwrite(id, hdr.image.user44, 'float');  % User Variable 44
fwrite(id, hdr.image.user45, 'float');  % User Variable 45
fwrite(id, hdr.image.user46, 'float');  % User Variable 46
fwrite(id, hdr.image.user47, 'float');  % User Variable 47
fwrite(id, hdr.image.user48, 'float');  % User Variable 48
fwrite(id, hdr.image.RegressorVal, 'float');  
fwrite(id, hdr.image.SliceAsset, 'float');  % Slice Asset in Asset Screen 
fwrite(id, hdr.image.PhaseAsset, 'float');  % Phase Asset in Asset Screen 
fwrite(id, hdr.image.sarValues, 'float');  % correspoding SAR values for defined terms 
fwrite(id, hdr.image.shim_fov, 'float');  
fwrite(id, hdr.image.shim_ctr_R, 'float');  
fwrite(id, hdr.image.shim_ctr_A, 'float');  
fwrite(id, hdr.image.shim_ctr_S, 'float');  
fwrite(id, hdr.image.dim_X, 'float');  % Image dimension - X
fwrite(id, hdr.image.dim_Y, 'float');  % Image dimension - Y
fwrite(id, hdr.image.pixsize_X, 'float');  % Image pixel size - X
fwrite(id, hdr.image.pixsize_Y, 'float');  % Image pixel size - Y
fwrite(id, hdr.image.ctr_R, 'float');  % Center R coord of plane image
fwrite(id, hdr.image.ctr_A, 'float');  % Center A coord of plane image
fwrite(id, hdr.image.ctr_S, 'float');  % Center S coord of plane image
fwrite(id, hdr.image.norm_R, 'float');  % Normal R coord
fwrite(id, hdr.image.norm_A, 'float');  % Normal A coord
fwrite(id, hdr.image.norm_S, 'float');  % Normal S coord
fwrite(id, hdr.image.tlhc_R, 'float');  % R Coord of Top Left Hand Corner
fwrite(id, hdr.image.tlhc_A, 'float');  % A Coord of Top Left Hand Corner
fwrite(id, hdr.image.tlhc_S, 'float');  % S Coord of Top Left Hand Corner
fwrite(id, hdr.image.trhc_R, 'float');  % R Coord of Top Right Hand Corner
fwrite(id, hdr.image.trhc_A, 'float');  % A Coord of Top Right Hand Corner
fwrite(id, hdr.image.trhc_S, 'float');  % S Coord of Top Right Hand Corner
fwrite(id, hdr.image.brhc_R, 'float');  % R Coord of Bottom Right Hand Corner
fwrite(id, hdr.image.brhc_A, 'float');  % A Coord of Bottom Right Hand Corner
fwrite(id, hdr.image.brhc_S, 'float');  % S Coord of Bottom Right Hand Corner
fwrite(id, hdr.image.float_padding, 'float');  % Please use this if you are adding any floats
fwrite(id, hdr.image.cal_fldstr, 'uint');  % Calibrated Field Strength (x10 uGauss)
fwrite(id, hdr.image.user_usage_tag, 'uint');  % Defines how following user CVs are to be filled in
fwrite(id, hdr.image.user_fill_mapMSW, 'uint');  % Define what process fills in the user CVs, ifcc or TIR
fwrite(id, hdr.image.user_fill_mapLSW, 'uint');  % Define what process fills in the user CVs, ifcc or TIR
fwrite(id, hdr.image.im_archived, 'int');  % Image Archive Flag
fwrite(id, hdr.image.im_complete, 'int');  % Image Complete Flag
fwrite(id, hdr.image.int_padding1, 'int');  % Please use this if you are adding any ints
fwrite(id, hdr.image.im_datetime, 'int');  % Allocation Image date/time stamp
fwrite(id, hdr.image.im_actual_dt, 'int');  % Actual Image date/time stamp
fwrite(id, hdr.image.tr, 'int');  % Pulse repetition time(usec)
fwrite(id, hdr.image.ti, 'int');  % Pulse inversion time(usec)
fwrite(id, hdr.image.te, 'int');  % Pulse echo time(usec)
fwrite(id, hdr.image.te2, 'int');  % Second echo echo (usec)
fwrite(id, hdr.image.tdel, 'int');  % Delay time after trigger (msec)
fwrite(id, hdr.image.mindat, 'int');  % Minimum Delay after Trigger (uSec)
fwrite(id, hdr.image.obplane, 'int');  % Oblique Plane
fwrite(id, hdr.image.slocfov, 'int');  % Slice Offsets on Freq axis
fwrite(id, hdr.image.obsolete1, 'int');  % Center Frequency (0.1 Hz)
fwrite(id, hdr.image.obsolete2, 'int');  % Auto Center Frequency (0.1 Hz)
fwrite(id, hdr.image.user_bitmap, 'int');  % Bitmap defining user CVs
fwrite(id, hdr.image.iopt, 'int');  % Imaging Options
fwrite(id, hdr.image.psd_datetime, 'int');  % PSD Creation Date and Time
fwrite(id, hdr.image.rawrunnum, 'int');  % RawData Run Number
fwrite(id, hdr.image.intr_del, 'int');  % Interimage/interloc delay (uSec)
fwrite(id, hdr.image.im_lastmod, 'int');  % Date/Time of Last Change
fwrite(id, hdr.image.im_pds_a, 'int');  % PixelData size - as stored
fwrite(id, hdr.image.im_pds_c, 'int');  % PixelData size - Compressed
fwrite(id, hdr.image.im_pds_u, 'int');  % PixelData size - UnCompressed
fwrite(id, hdr.image.thresh_min1, 'int');  % Lower Range of Pixels 1
fwrite(id, hdr.image.thresh_max1, 'int');  % Upper Range of Pixels 1
fwrite(id, hdr.image.thresh_min2, 'int');  % Lower Range of Pixels 2
fwrite(id, hdr.image.thresh_max2, 'int');  % Upper Range of Pixels 2
fwrite(id, hdr.image.numslabs, 'int');  % Number of 3D Slabs
fwrite(id, hdr.image.locsperslab, 'int');  % Slice Locs Per 3D Slab
fwrite(id, hdr.image.overlaps, 'int');  % # of Slice Locs on Each Slab Which Overlap N eighbors
fwrite(id, hdr.image.slop_int_4, 'int');  % Image Filtering 0.5/0.2T
fwrite(id, hdr.image.dfax, 'int');  % Diffusion Direction for DW-EPI 
fwrite(id, hdr.image.fphase, 'int');  % Number Of Phases
fwrite(id, hdr.image.offsetfreq, 'int');  % Offset Frequency - Mag.Transfer
fwrite(id, hdr.image.b_value, 'int');  % B-value for DW-EPI
fwrite(id, hdr.image.iopt2, 'int');  % Imaging Option2
fwrite(id, hdr.image.ihtagging, 'int');  % tag type 
fwrite(id, hdr.image.ihtagspc, 'int');  % tag space 
fwrite(id, hdr.image.ihfcineim, 'int');  % Fast CINE interpolation method
fwrite(id, hdr.image.ihfcinent, 'int');  % Fast CINE normalization type
fwrite(id, hdr.image.num_seg, 'int');  % YMSge05074
fwrite(id, hdr.image.oprtarr, 'int');  % Respiratory Trigger windo
fwrite(id, hdr.image.averages, 'int');  % Number of averages for spectro
fwrite(id, hdr.image.station_index, 'int');  % Station Index
fwrite(id, hdr.image.station_total, 'int');  % Station Total
fwrite(id, hdr.image.iopt3, 'int');  % Imaging Option3
fwrite(id, hdr.image.delAcq, 'int');  % Delay after Acquisition (MP / fMRI screen) 
fwrite(id, hdr.image.rxmbloblen, 'int');  % fMRI: RXM blob size 
fwrite(id, hdr.image.rxmblob_pad, 'int');  % Changed to 32-bit pad for 64-bit recon build 
fwrite(id, hdr.image.im_no, 'int');  % Image Number
fwrite(id, hdr.image.imgrx, 'int');  % Image from which prescribed
fwrite(id, hdr.image.temp_phases, 'int');  % Temporal Phases
fwrite(id, hdr.image.MEG_freq, 'int');  % MEG Frequency 
fwrite(id, hdr.image.driver_amp, 'int');  % Driver Amplitute
fwrite(id, hdr.image.driverCyc_Trig, 'int');  % Driver Cycle per Trigger
fwrite(id, hdr.image.MEG_dir, 'int');  % MEG Direction
fwrite(id, hdr.image.int_padding2, 'int');  % Please use this if you are adding any ints
fwrite(id, hdr.image.imatrix_X, 'short');  % Image matrix size - X
fwrite(id, hdr.image.imatrix_Y, 'short');  % Image matrix size - Y
fwrite(id, hdr.image.im_exno, 'ushort');  % Exam number for this image
fwrite(id, hdr.image.img_window, 'ushort');  % Window Value
fwrite(id, hdr.image.img_level, 'short');  % Level Value
fwrite(id, hdr.image.numecho, 'short');  % Number of echoes
fwrite(id, hdr.image.echonum, 'short');  % Echo Number
fwrite(id, hdr.image.im_uniq, 'short');  % The Make-Unique Flag
fwrite(id, hdr.image.im_seno, 'short');  % Series Number for this image
fwrite(id, hdr.image.contmode, 'short');  % Image Contrast Mode
fwrite(id, hdr.image.serrx, 'short');  % Series from which prescribed
fwrite(id, hdr.image.screenformat, 'short');  % Screen Format(8/16 bit)
fwrite(id, hdr.image.plane, 'short');  % Plane Type
fwrite(id, hdr.image.im_compress, 'short');  % Image compression type for allocation
fwrite(id, hdr.image.im_scouttype, 'short');  % Scout Type (AP or lateral)
fwrite(id, hdr.image.contig, 'short');  % Continuous Slices Flag
fwrite(id, hdr.image.hrtrate, 'short');  % Cardiac Heart Rate (bpm)
fwrite(id, hdr.image.trgwindow, 'short');  % Trigger window (% of R-R interval)
fwrite(id, hdr.image.imgpcyc, 'short');  % Images per cardiac cycle
fwrite(id, hdr.image.obsolete3, 'short');  % Actual Transmit Gain (.1 db)
fwrite(id, hdr.image.obsolete4, 'short');  % Actual Receive Gain Analog (.1 db)
fwrite(id, hdr.image.obsolete5, 'short');  % Actual Receive Gain Digital (.1 db)
fwrite(id, hdr.image.mr_flip, 'short');  % Flip Angle for GRASS scans (deg.)
fwrite(id, hdr.image.cphase, 'short');  % Total Cardiac Phase prescribed
fwrite(id, hdr.image.swappf, 'short');  % Swap Phase/Frequency Axis
fwrite(id, hdr.image.pauseint, 'short');  % Pause Interval (slices)
fwrite(id, hdr.image.obsolete6, 'short');  % Auto Transmit Gain (0.1 dB)
fwrite(id, hdr.image.obsolete7, 'short');  % PreScan R1 - Analog
fwrite(id, hdr.image.obsolete8, 'short');  % PreScan R2 - Digital
fwrite(id, hdr.image.not_used_1, 'short');  % Available for use 
fwrite(id, hdr.image.imode, 'short');  % Imaging Mode
fwrite(id, hdr.image.pseq, 'short');  % Pulse Sequence
fwrite(id, hdr.image.pseqmode, 'short');  % Pulse Sequence Mode
fwrite(id, hdr.image.ctyp, 'short');  % Coil Type
fwrite(id, hdr.image.surfctyp, 'short');  % Surface Coil Type
fwrite(id, hdr.image.surfcext, 'short');  % Extremity Coil Flag
fwrite(id, hdr.image.supp_tech, 'short');  % SAT fat/water/none
fwrite(id, hdr.image.slquant, 'short');  % Number of slices in this scan group
fwrite(id, hdr.image.gpre, 'short');  % Graphically prescribed
fwrite(id, hdr.image.satbits, 'short');  % Bitmap of SAT selections
fwrite(id, hdr.image.scic, 'short');  % Surface Coil Intensity Correction Flag
fwrite(id, hdr.image.satxloc1, 'short');  % R-side SAT pulse loc rel to lndmrk
fwrite(id, hdr.image.satxloc2, 'short');  % L-side SAT pulse loc rel to lndmrk
fwrite(id, hdr.image.satyloc1, 'short');  % A-side SAT pulse loc rel to lndmrk
fwrite(id, hdr.image.satyloc2, 'short');  % P-side SAT pulse loc rel to lndmrk
fwrite(id, hdr.image.satzloc1, 'short');  % S-side SAT pulse loc rel to lndmrk
fwrite(id, hdr.image.satzloc2, 'short');  % I-side SAT pulse loc rel to lndmrk
fwrite(id, hdr.image.satxthick, 'short');  % Thickness of X-axis SAT pulse
fwrite(id, hdr.image.satythick, 'short');  % Thickness of Y-axis SAT pulse
fwrite(id, hdr.image.satzthick, 'short');  % Thickness of Z-axis SAT pulse
fwrite(id, hdr.image.flax, 'short');  % Phase contrast flow axis
fwrite(id, hdr.image.venc, 'short');  % Phase contrast velocity encoding
fwrite(id, hdr.image.thk_disclmr, 'short');  % Slice Thickness
fwrite(id, hdr.image.obsolete9, 'short');  % Auto/Manual Prescan flag
fwrite(id, hdr.image.obsolete10, 'short');  % Bitmap of changed values
fwrite(id, hdr.image.image_type, 'short');  % Magnitude, Phase, Imaginary, or Real
fwrite(id, hdr.image.vas_collapse, 'short');  % Collapse Image
fwrite(id, hdr.image.proj_alg, 'short');  % Projection Algorithm
fwrite(id, hdr.image.echo_trn_len, 'short');  % Echo Train Length for Fast Spin Echo
fwrite(id, hdr.image.frac_echo, 'short');  % Fractional Echo - Effective TE Flag
fwrite(id, hdr.image.prep_pulse, 'short');  % Preporatory Pulse Option
fwrite(id, hdr.image.cphasenum, 'short');  % Cardiac Phase Number
fwrite(id, hdr.image.var_echo, 'short');  % Variable Echo Flag
fwrite(id, hdr.image.scanactno, 'short');  % Scan Acquisition Number
fwrite(id, hdr.image.vasflags, 'short');  % Magnitude Weighting Flag
fwrite(id, hdr.image.integrity, 'short');  % GE Image Integrity
fwrite(id, hdr.image.freq_dir, 'short');  % Frequency Direction
fwrite(id, hdr.image.vas_mode, 'short');  % Vascular Mode
fwrite(id, hdr.image.pscopts, 'short');  % bitmap of prescan options
fwrite(id, hdr.image.obsolete11, 'short');  % gradient offset in X-direction
fwrite(id, hdr.image.obsolete12, 'short');  % gradient offset in Y-direction
fwrite(id, hdr.image.obsolete13, 'short');  % gradient offset in Z-direction
fwrite(id, hdr.image.unoriginal, 'short');  % identifies image as original or unoriginal
fwrite(id, hdr.image.interleaves, 'short');  % number of EPI shots
fwrite(id, hdr.image.effechospace, 'short');  % effective echo spacing for EPI
fwrite(id, hdr.image.viewsperseg, 'short');  % views per segment
fwrite(id, hdr.image.rbpm, 'short');  % respiratory rate, breaths per min
fwrite(id, hdr.image.rtpoint, 'short');  % respiratory trigger point as percent of max.
fwrite(id, hdr.image.rcvrtype, 'short');  % type of receiver used
fwrite(id, hdr.image.sarMode, 'short');  % Sar Ctrl Mode (Normal, 1st or 2nd) 
fwrite(id, hdr.image.dBdtMode, 'short');  % dBdt Ctrl Mode (Normal, 1st or 2nd) 
fwrite(id, hdr.image.govBody, 'short');  % Governing Body MHW/IEC/FDA 
fwrite(id, hdr.image.sarDefinition, 'short');  % Defined terms avaialble 
fwrite(id, hdr.image.no_shimvol, 'short');  
fwrite(id, hdr.image.shim_vol_type, 'short');  
fwrite(id, hdr.image.current_phase, 'short');  % Current Phase for this image (DP)
fwrite(id, hdr.image.art_level, 'short');  % Acoustic reduction level 
fwrite(id, hdr.image.slice_group_number, 'short');  % value 0=no group defined, 1=this slice belongs to group 1 and so on
fwrite(id, hdr.image.number_of_slice_groups, 'short');  % value 0=no groups defined, 1=total group is one and so on
fwrite(id, hdr.image.show_in_autoview, 'short');  % if 1 image will be displayed in auto view 
fwrite(id, hdr.image.slice_number_inGroup, 'short');  % value 0=no image, 1=this is the 1st image in group and so on
fwrite(id, hdr.image.specnuc, 'short');  % Imaged Nucleus 1H=> Hydrogen,13C=>carbon,23NA=>Sodium etc
fwrite(id, hdr.image.label_duration, 'ushort');  % 3DASL: Duration of Lable or Control Pulse
fwrite(id, hdr.image.short_padding, 'short');  % Please use this if you are adding any shorts
fwrite(id, hdr.image.psdname, 'char');  % Pulse Sequence Name
fwrite(id, hdr.image.proj_name, 'char');  % Projection Algorithm Name
fwrite(id, hdr.image.psd_iname, 'char');  % PSD name from inside PSD
fwrite(id, hdr.image.im_diskid, 'char');  % Disk ID for this Image
fwrite(id, hdr.image.pdid, 'char');  % Pixel Data ID
fwrite(id, hdr.image.im_suid, 'char');  % Suite id for this image
fwrite(id, hdr.image.contrastIV, 'char');  % IV Contrast Agent
fwrite(id, hdr.image.contrastOral, 'char');  % Oral Contrast Agent
fwrite(id, hdr.image.loc_ras, 'char');  % RAS letter of image location
fwrite(id, hdr.image.forimgrev, 'char');  % Foreign Image Revision
fwrite(id, hdr.image.cname, 'char');  % Coil Name
fwrite(id, hdr.image.im_verscre, 'char');  % Genesis Version - Created
fwrite(id, hdr.image.im_verscur, 'char');  % Genesis Version - Now
fwrite(id, hdr.image.im_alloc_key, 'char');  % 
fwrite(id, hdr.image.ref_img, 'char');  % Reference Image Field
fwrite(id, hdr.image.sum_img, 'char');  % Summary Image Field
fwrite(id, hdr.image.filter_mode, 'char');  % String Slop Field 1
fwrite(id, hdr.image.slop_str_2, 'char');  % String Slop Field 2
fwrite(id, hdr.image.image_uid, 'char');  % Image Unique ID
fwrite(id, hdr.image.sop_uid, 'char');  % Service Obj Class Unique ID
fwrite(id, hdr.image.GEcname, 'char');  % GECoilname for the cname 
fwrite(id, hdr.image.usedCoilData, 'char');  % Concatenated str of coilcode and chip serialID 
fwrite(id, hdr.image.astcalseriesuid, 'char');  
fwrite(id, hdr.image.purecalseriesuid, 'char');  
fwrite(id, hdr.image.xml_psc_shm_vol, 'char');  
fwrite(id, hdr.image.rxmpath, 'char');  
fwrite(id, hdr.image.psdnameannot, 'char');  % Pulse Sequence Name Annotation 
fwrite(id, hdr.image.img_hdr_padding, 'char');  
