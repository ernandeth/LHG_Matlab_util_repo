function [np,ns,nv,pss,lro,thk,data,seqfil,array, array_val]=ReadFID5(FID_filename);% This function reads "fid" files from Varian system.% The input parameter is "filename" that contains the path% and the file name of the "fid" file.% If the file name is omitted, then the program asks the user% the name and location of the "procpar" file using a MATLAB% predefined window to open a file.% The output parameters are:%    Data File Header "datafilehead" (structure) that contains:%       nblocks = Number of blocks in file%       ntraces = Number of traces per block%       np = Number of elements per trace%       ebytes = Number of bytes per element%       tbytes = Number of bytes per trace%       bbytes = Number of bytes per block%       vers_id = Software version, file_id status bits%       status = Status of whole file%       nbheaders = Number of block headers per block%    Data Block Header "datablockhead" (structure) that contains:%       scale%       status%       index%       mode%       ctcount%       lpval%       rpval%       lvl%       tlt%    "data" (Complex matrix with FID's)%% Rev. 2.0   Jun/27/2001% Francisco M. Martinez S.% Please send comments and/or modifications to sfmartin@umich.edu%if nargin==0    %    [FID_file,FID_path]=uigetfile('*fid*','Free Induction Decays (Raw Data - FID File)');    %    %    cd(FID_path);    %    %    FID_filename=strcat(FID_path,FID_file);    FID_filename='fid';    FID_path='';endFID_path='';filedata=fopen(FID_filename,'r','ieee-be');procparpath = [FID_path 'procpar'];[np,nv,lro,ns,pss,thk, acqcycles, array, seqfil]=Find_param(procparpath,{'np','nv','lro','ns','pss','thk','acqcycles', 'array', 'seqfil'});%********************Find arrayed values if any********%array;if strcmp(array,{''}) ==1    %array_val = Find_param(procparpath,{array})else    array_val = Find_param(procparpath,array);    s_array= size(array_val);    acqcycles;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% File Header%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%datafilehead.nblocks=fread(filedata,1,'int32')	% Number of blocks in filedatafilehead.ntraces=fread(filedata,1,'int32')	% Number of traces per blockdatafilehead.np=fread(filedata,1,'int32');			% Number of elements per tracedatafilehead.ebytes=fread(filedata,1,'int32');		% Number of bytes per elementdatafilehead.tbytes=fread(filedata,1,'int32');		% Number of bytes per tracedatafilehead.bbytes=fread(filedata,1,'int32');		% Number of bytes per blockdatafilehead.vers_id=fread(filedata,1,'int16'); 	% Software version, file_id status bits \datafilehead.status=fread(filedata,1,'int16');  	% Status of whole file                  / Check bit orderdatafilehead.nbheaders=fread(filedata,1,'int32');	% Number of block headers per block% %**************Read the data in**************data_block=fread(filedata,[datafilehead.np*datafilehead.ntraces+7,datafilehead.nblocks],'int32');%*************get rid of excess 7 bytes of data in front of each block of datadata_block=data_block(8:end,:);%  size(data_block)%********************turn into complexed matrices ready for FFT********************data = data_block(1:2:end,:)+j*data_block(2:2:end,:);%% note if flashc or rarec was used the dimensions of data is [np/2,nv*ns*s_array], else it is opposite [nv*nslices*s_array,np/2]whos datareturn