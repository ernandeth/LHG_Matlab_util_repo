function slices = spmimg(spmtype)

%
% function slices = spmimg(spmtype)
%
% Luis Hernandez
% last edit 1-9-98
%
% slices = data structure with image slices
% spmtype = 'F' ot 't' (type of ststistical map)
%
% In its present state, this function generates an array of slices
% (see makslice.m) from the SPM*.mat files that are generated by 
% SPM96.  
% The spmtype argument indicates wheter it is a t-map or an F-map.
% The argument can be t or f (case insensitive)
% It loads a *.mat file with the XYZ coordinates and a *.mat 
% file with the corresponding statistical parameters.
% The user is propmted to select an analyze image to use for scaling 
% purposes. If no file is selected, the default will be:
%
%   11 slices
%   64x64 matrix
%   4.375 mm pixels
%   5 mm slice thickness
%
% From these files, it generates an ANALYZE format slice set.
% Zeros are placed where no SPM values are speciefied.


   
   % Determine the dimensions of the spm->analyze output data
   % Read in Analyze hdr info:
   
   [f p] = uigetfile('*.hdr','Select Image file with appropriate dimensions - CANCEL to use defaults');
   hdrname = strcat(p,f);
   cd(p);
  
   if hdrname == 0
      hdrname = '/export/home/hernan/matlab/default.hdr'
      errormesg('using the default header .../export/home/hernan/matlab/default.hdr');
   end
  
   % Extract analyze header information from file

   hdr = read_hdr(hdrname);
   no_slices = hdr.zdim;
   dim = hdr.xdim;          % assuming a square matrix
   PIX_mm = hdr.xsize;
   SLI_mm = hdr.zsize;

      
   % Initialize all slices.

   slices = makslice;
   for i=1:no_slices, 
      slices(i).n_slices = no_slices;
      slices(i).xdim = dim;
      slices(i).ydim = dim;
      slices(i).slicenum =i;
      slices(i).pix_mm = PIX_mm;
      slices(i).slice_mm = SLI_mm;
      slices(i).data = zeros(dim,dim);
   end;
   
   % Read in the xyz coordinates corresponding to the spm values

   [f p] = uigetfile('*.mat', 'Select xyz coordinates file');
   name = strcat(p,f);

   if name ~= 0
      load(name);
	cd(p);
   end
   
   % Read in the spmvalues

   [f p] = uigetfile('*.mat', 'Select SPM file');
   name = strcat(p,f);

   if name ~=0
      load(name);
	cd(p);
   end
   
   % Decide whether the SPM loaded is a t or an F map

   switch upper(spmtype)

   case 'T'
      if exist('SPMt')
         spmvalues = SPMt
      else 
         errormesg('SPMt doesnot exist ')
         return
      end
      
   case 'F'
      if exist('SPMF')
         spmvalues = SPMF
      else 
         errormesg('SPMF doesnot exist ')
         return   
      end
      
   otherwise
      errormesg('Variable not found')
      whos
      return;      
   end
   

   % Scale the xyz coordinates to pixel numbers and 
   % replace zeros at those locations with the parameter values

   pixels = XYZ_conv(XYZ, PIX_mm, SLI_mm, dim);
   sz = size(pixels);
   for i = 1 : sz(1),
      x = pixels(i,1);
      y = pixels(i,2);
      z = pixels(i,3);
      slices(z).data(x,y) = spmvalues(i);
   end
      
return;


function pix_mm = XYZ_conv(XYZ,PIX_mm, SLI_mm, dim)

%function pix_mm = XYZ_conv(XYZ)
% Written by Pete Santago
%
% Convert the XYZ coordinates that are given by SPM when
%   using results to pixel coordinates in fMRI space.
%   The following is the orientation as used by spm.
%       x: left -> right
%       y: post -> ant
%       z: inf  -> sup
%
% fMRI uses the (x,y)=(0,0) as the origin. This is the upper left
%   corner, or the rightmost and most anterior.
%
% When acquiring only part of the brain, we typicall specify the
%   origin as (x,y,z) = (32,32,0). This is in pixels and SPM
%   allows (0,0,0) as the origin, so adjust accordingly.
%   Thus, negative x is toward the left, negative y is toward
%   the posterior. Z is positive since we use 0 as the most inferior.
%
% Thus, a negative y should come out with a value less than 32
%   indicating more anterior.
%   Negative x is to the left, thus giving a value greater than 32.
%

%   PIX_mm = 4.375;
%   SLI_mm = 5.00;
%   X_org = 32;
%   Y_org = 32;

   X_org = dim/2;
   Y_org = dim/2;
   x_mm = XYZ(1,:)';
   y_mm = XYZ(2,:)';
   z_mm = XYZ(3,:)';
   
   x_pix = X_org - x_mm/PIX_mm;
   y_pix = Y_org - y_mm/PIX_mm;
   z_pix = z_mm/SLI_mm;
   
   pix_mm = [x_pix y_pix z_pix]
   
return
