function result = ortho2005(args,varargin)
% function result = ortho2005(args,varargin)
%
% (c) 2005 Luis Hernandez-Garcia
% University of Michigan
% report bugs to:  hernan@umich.edu
%
% last edits: Oct 18,2005
%
% This is a program to visualize overlays of FMRI data, extract time
% series and do some quick analyses on those time series like FFT, gaussian
% filters, event averaging, detrending.
% Images should be in Analyze (AVW) format
%
%
%         USAGE:
%
% This program will do as much as it can with the information provided.
% ie - If you give onset times, it will assume you want event averages,
% You can run this program in a couple of ways:
% The arguments to this function can go in either as a structure like this:
% (fell free to copy and paste the following in order to run the program.  it's what I do)
%
%     args.ROIsize = 0;
%     args.ROItype = 'cube';
%     args.threshold = [0.0001 10];
%     args.threshold2 = [0.0001 10];
%     args.onsets = [];
%     args.window = 10;
%     args.spm_file = [];
%     args.spm_file2 = [];
%     args.anat_file = [];
%     args.tseries_path = [];
%     args.tseries_file = [];
%     args.tseries_file2 = [];
%     args.doDetrend = 0;
%     args.doGfilter = 0;
%     args.doFFT = 0;
%     args.ignore_origin = 0;
%     args.wscale = [];
%     args.interact = 1;
%     args.xyz=[];
%     args.mask_file = [];
%     args.output_name = 'Ortho';
%     args.voxFile = [];
%     args.doMovie = 0;
%     args.causalMap = 0;
%     args.doConnect = 0;
%     args.doSufNec = 0;
%
% then you call
%
%   ortho2005(args)
%
% OR as variable arguments when you just want to change a couple of the
% defaults. The general syntax is
%
%   ortho2005([],'argument1', value1, 'argument2', value2, ....)
%
% for example:
%
%    ortho2005( [], 'anat_file', '/usr/data/vol_0001.img', 'ROIsize', 1);
%
%
%
%       INPUTS (arguments).
%       (their default values are in the above struct)
%
% ROIsize : this is the 'radius' of the ROI if it's a sphere
%       or the number of neighbors to consider if it's a cubw.
%       it's in mm for the sphere case, and voxels for the cube case
%
% ROItype :  what type of ROI you'll useyou can choose
%       'cube' : average the neighbors in each direction
%       'voxFile': average the values in the voxels specified in an ASCII file
%       'sphere':  average the voxels in a sphere, but only those whose
%              statistics are above threshold
%       'maskFile'  : average the voxels that are non-zero in a mask img file
%
% threshold : [min max] intensity window for display of the overlay and for ROI
%       averaging.
%
% threshold2 : [min max] intensity window for display of the overlay and for ROI
%       averaging of the second stats map.
%
% voxFile : an ASCI file containing three columns specifying which voxels
%       to extract time series from.  Note- uses scan units and ignores the
%       origin by default.
%
% mask_file = binary mask image to use if you want to choose your ROIs that
%       way
%
% onsets : a vector of onset times, specified in scan units for window averaging;
%
% window : The window of time to average after ach onset (peristimulus interval)
%       also in units of scans;
%
% spm_file : The statistical map to overlay on the orthogonal views;
%
% anat_file : The anatomical image file to overlay;
%
% tseries_path :  this doesn't do aquat right now
%
% tseries_file : one of the files in the time series.
%       If the data are 4D, ortho2005 should recognize it and read it in= [];
%
% tseries_file2 :  this doesn't do squat yet, either = [];
%
% doMovie : show a movie loop of the time series. only the time series
%       image is required
%
% doDetrend :  Detrend the data by fitting and removing a 4th order polynomial.
%       usually works like a charm!;
%
% doGfilter:  Filter the data with a simple Gaussian filter in time.
%       kernel width (SD) is hard wired to 4 scans ;
%
% doFFT :  show the FFT magnitude and phase of the time series in a separate window;
%
% ignore_origin :  ignore the origin information from SPM.  This can be tricky;
%
% wscale :  window level scaling for display of the anatomical images
%       if you want to do it manually;
%
% interact : allow the user to interactively pick points from the image, or just
%       do one set of coordinates and exit the program.  When interactive,
%       you exit the program by clicking to the left of the images, or by
%       hitting the Z key.
%
% xyz : voxel coordinates to analyse when not running interactively.
%
% output_name : a prefix to put on all the files generated by the program ('Ortho');
%
% causalMap : this will launch a set of programs that takes the time course from
%       the chosen ROI as an examplar and computes maps (img files)
%       of the following measures of relationship between the ROI and other voxels:
%          -Ganger causality : F, Fa->b , Fb->b, pvalue(F)
%          -Mutual Information:
%          -correlation coefficient (rho)
%          -DOminance
%          -Asymmetry of the joint histogram
%
%       Outputs from ortho2005
%
%  you get some very nice displays of whatever you chose.  if you click the
%  right mouse button instead of the left one, you get these ASCII files:
%
%       *voxels.dat : the voxels that data was extracted from
%       *data.dat: the raw time series data from theose voxels
%       *avg.dat : the means and standard deviation of the events
%
%

global args
if ~exist('args')
    args = [];
end

if isempty(args)
    args.ROIsize = 0;
    args.ROItype = 'cube';
    args.threshold = [0.0001 10];
    args.threshold2 = [0.0001 10];
    args.onsets = [];
    args.window = 20;
    args.spm_file = [];
    args.spm_file2 = [];
    args.anat_file = [];
    args.tseries_path = [];
    args.tseries_file = [];
    args.tseries_file2 = [];
    args.doDetrend = 0;
    args.doGfilter = 0;
    args.doFFT = 0;
    args.ignore_origin = 0;
    args.wscale = [];
    args.interact = 1;
    args.xyz=[];
    args.mask_file = [];
    args.output_name = 'Ortho';
    args.voxFile = [];
    args.doMovie = 0;
    args.causalMap = 0;
    args.doConnect = 0;
    args.doSufNec = 0;
end

if nargin==0
    result=args;
    return
end

% Parse the arguments from the command line to override defaults
for a=1:2:length(varargin)
    
    argtype = lower( cell2mat(varargin(a) ));
    
    if  strcmp(argtype, 'roisize');
        args.ROIsize = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'roitype');
        args.ROItype = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'threshold');
        args.threshold = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'onsets')
        args.onsets = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'window')
        args.window = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'spm_file');
        args.spm_file = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'spm_file2');
        args.spm_file2 = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'anat_file')
        args.anat_file = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'tseries_path')
        args.tseries_path = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'tseries_file')
        args.tseries_file = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'tseries_file2')
        args.tseries_file2 = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'dodetrend')
        args.doDetrend = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'dotsmooth')
        args.doTsmooth = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'dofft')
        args.doFFT = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'domovie')
        args.doMovie = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'ignore_origin')
        args.ignore_origin = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'wscale')
        args.wscale = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'interact')
        args.interact = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'xyz')
        args.xyz = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'mask_file')
        args.mask_file = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'output_name')
        args.output_name = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'voxfile')
        args.voxFile = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'causalmap')
        args.causalMap = cell2mat(varargin(a+1));
        
    elseif  strcmp(argtype, 'doconnect')
        args.doConnect = cell2mat(varargin(a+1));
        
        
    else
        fprintf('\n\n  UNKNOWN OPTION: %s ', argtype);
        fprintf('\n  Get your act together \n\n');
    end
    
end

if isempty(args.anat_file)
    args.anat_file=args.tseries_file;
end

args

global SPM_scale_factor
global myfig ACTIVE EvFig FFTfig histFig
ACTIVE = 1;
% define some buttons for interactively adjusting the ROIsize and
% threshold
% the default will be for a WINPC, although I never use one....
UPKEY = 30;
DNKEY = 31;
RTKEY = 29;
LTKEY = 28;
i=1;
j=1;
if strcmp(computer,'GLNX86') || ...
        strcmp(computer,'SOL2')|| ...
        strcmp(computer,'MACI')
    UPKEY = 30;
    DNKEY = 31;
    RTKEY = 29;
    LTKEY = 28;
end
if strcmp(computer,'MAC')
    UPKEY = 56;
    DNKEY = 50;
    RTKEY = 54;
    LTKEY = 52;
end

isNIFTI=0;

if ~isempty(args.onsets)
    % open a window for displaying the time courses
    EvFig = figure;
    set(gcf,'Position',[1 1 400 300]);
    set(gcf, 'Name', 'Events image')
    
    strTag = getincrementaltag('evfig');
    set(gcf,'tag',strTag);
end

if args.doFFT
    % open a window for displaying the frequency content of the time courses
    FFTfig = figure;
    set(gcf,'Position',[400 1 400 300]);
    set(gcf, 'Name', 'Frequency Spectrum')
    strTag = getincrementaltag('fftfig');
    set(gcf,'tag',strTag);
end

% Figure with histograms
histFig = figure;
set(gcf,'Position',[620 400 400 380]);
set(gcf, 'Name', 'Histograms')
strTag = getincrementaltag('histfig');
set(gcf,'tag',strTag);
% set(gcf,'WindowButtonUpFcn','histrelease');

% Main figure with ortho views
myfig = figure;
set(gcf, 'Name', 'Orthogonal Views')
set(gcf,'Position',[1 400 600 540]);

strTag = getincrementaltag('myfig');
set(gcf,'tag',strTag);

if ~isempty(args.anat_file)
    % Load the anatomical image into memory:
    anat_file = args.anat_file;
    hdr = read_hdr(anat_file);
    
    if hdr.xsize < 0;
        fprintf('\nWARNING: found neg. xsize in Anatomical header. Ignoring the sign.');
        fprintf('\nIs this right? Look for THIS in the code and change if you dont like it');
        hdr.xsize = abs(hdr.xsize);
    end
    
    fprintf('\nLoading ... %s', anat_file);
    anat_data = read_img(hdr,anat_file);
    % identify whether this is already a 3D matrix. If not, make it a 3D matrix
    %if (size(size(anat_data),2) < 3)
    if hdr.tdim>1
        anat_data = reshape(anat_data(1,:), hdr.xdim, hdr.ydim, hdr.zdim);
    end
    anat_scale =  SPM_scale_factor;
    
    %anat_data = anat_data*anat_scale;
    
    fprintf('\nheader info: %d x %d x %d', hdr.xdim, hdr.ydim, hdr.zdim);
    fprintf('\nvox size: %d x %d x %d', hdr.xsize, hdr.ysize, hdr.zsize);
    
    D = anat_data;
    
    % Stash img data info the figure
    sDat = guidata(myfig);
    sDat.img = anat_data;
    guidata(myfig,sDat);
    
    if isempty(args.spm_file)
        % configure colormap
        my_map=(0:255)';
        my_map=[my_map my_map my_map]/256;
        colormap(my_map);
    end
    
    % scale image to fit colormap
    if ~isempty(args.wscale)
        wscale = args.wscale
        D = (D - wscale(1))*256 / (wscale(2)-wscale(1));
        D(find(D>256)) = 256;
        D(find(D<1)) = 1;
    else
        
        %range= max(D(:)) - min(D(:));
        %range = 2*std(D(:))
        %D = (D - median(D(:))- range/2 )*256 / range;
        %D = (D - min(D(:)))*256 / range;
        %D = (D - median(D(:))- range/2 )*256 / range;
        wscale(1) = min(D(:));
        wscale(2) = max(D(:));
        args.wscale = wscale;
        D = (D - wscale(1))*256 / (wscale(2)-wscale(1));
        D(find(D>256)) = 256;
        D(find(D<1)) = 1;
    end
    Dscaled = D;
end
figure(histFig), subplot(3,1,1),hist(double(anat_data(anat_data~=0)),100), title('Anatomical')
set(gca,'tag','anat_hist');
%hScaleWinAnat = makeslidingwindow(myfig,'anat_hist',args.wscale);


figure(myfig)


if ~isempty(args.spm_file)
    % load SPM into memory and create the overlay
    spm_file = args.spm_file;
    fprintf('\nLoading ... %s', spm_file);
    spm_hdr = read_hdr(spm_file);
    spm_data = read_img(spm_hdr,spm_file);
    spm_data = double(spm_data);
    % get rid of the NaNs
    spm_data(find(spm_data==NaN))=0;
    spm_data = reshape(spm_data, spm_hdr.xdim, spm_hdr.ydim, spm_hdr.zdim);
    spm_scale =  SPM_scale_factor;
    
    
    %spm_data = spm_data*spm_scale;
    figure(histFig), subplot(3,1,2),hist(spm_data(spm_data~=0),100), title('Stats Map (Red)')
    set(gca,'tag','spm1_hist');
    %hScaleWinSPM1 = makeslidingwindow(myfig,'spm1_hist',args.threshold);
    figure(myfig)
    subplot(2,2,4), hist(spm_data(spm_data~=0),100), axis on, title('Stats Map'),
    
    
    % resample the paramter map to fit the anatomical one
    [x,y,z] = meshgrid(1:spm_hdr.ydim , 1:spm_hdr.xdim, 1:spm_hdr.zdim);
    [xi,yi, zi] = meshgrid(1:hdr.ydim , 1:hdr.xdim, 1:hdr.zdim);
    
    % optional in case the origin is not set in the image headers...
    if args.ignore_origin==1
        spm_hdr.origin = [1 1 1];
        hdr.origin = [1 1 1];
        func_hdr.origin = [1 1 1];
        
    end
    
    if spm_hdr.xsize < 0;
        fprintf('\nWARNING: found neg. xsize in SPM header. Ignoring the sign.');
        fprintf('\nIs this right? Look for THIS in the code and change if you dont like it');
        spm_hdr.xsize = abs(spm_hdr.xsize);
    end
    
    x = ( x - spm_hdr.origin(1) )* spm_hdr.xsize;
    y = ( y - spm_hdr.origin(2) )* spm_hdr.ysize;
    z = ( z - spm_hdr.origin(3) )* spm_hdr.zsize;
    
    xi = ( xi - hdr.origin(1) )* hdr.xsize;
    yi = ( yi - hdr.origin(2) )* hdr.ysize;
    zi = ( zi - hdr.origin(3) )* hdr.zsize;
    
    if hdr.zdim >1
        spm_dataR = interp3(x,y,z, spm_data, xi,yi,zi,'nearest');
    else
        spm_dataR=spm_data;
    end
    
    [D , inds]= mk_overlay(args.threshold(1), D, spm_dataR, 257);
    
    sDat = guidata(myfig);
    % sDat.spm_img = spm_data;
    sDat.spm_img = spm_dataR;
    guidata(myfig,sDat);
    
    
    %configure the colormap:
    set_func_colors
    
    xstretch = hdr.xdim/spm_hdr.xdim;
    ystretch = hdr.ydim/spm_hdr.ydim;
    zstretch = hdr.zdim/spm_hdr.zdim;
else
    xstretch = 1;
    ystretch = 1;
    zstretch = 1;
end


if ~isempty(args.spm_file2)
    % load SPM into memory and create the overlay
    spm_file2 = args.spm_file2;
    fprintf('\nLoading ... %s', spm_file2);
    spm_hdr2 = read_hdr(spm_file2);
    if spm_hdr2.xsize < 0;
        fprintf('\nWARNING: found neg. xsize in SPM header. Ignoring the sign.');
        fprintf('\nIs this right? Look for THIS in the code and change if you dont like it');
        spm_hdr2.xsize = abs(spm_hdr2.xsize);
    end
    spm_data2 = read_img(spm_hdr2,spm_file2);
    % get rid of the NaNs
    spm_data2(find(spm_data2==NaN))=0;
    spm_data2 = reshape(spm_data2, spm_hdr.xdim, spm_hdr.ydim, spm_hdr.zdim);
    spm_scale2 =  SPM_scale_factor;
    spm_data2 = double(spm_data2);
    %spm_data2 = spm_data2*spm_scale2;
    figure(histFig), subplot(3,1,3),hist(spm_data2(spm_data2~=0),100), title('Stats Map (Blue)')
    set(gca,'tag','spm2_hist');
    %hScaleWinSPM2 = makeslidingwindow(myfig,'spm2_hist',args.threshold2);
    figure(myfig)
    
    % resample the paramter map to fit the anatomical one
    [x,y,z] = meshgrid(1:spm_hdr2.ydim , 1:spm_hdr2.xdim, 1:spm_hdr2.zdim);
    [xi,yi, zi] = meshgrid(1:hdr.ydim , 1:hdr.xdim, 1:hdr.zdim);
    
    % optional in case the origin is not set in the image headers...
    if args.ignore_origin==1
        spm_hdr2.origin = [1 1 1];
        hdr.origin = [1 1 1];
        func_hdr.origin = [1 1 1];

    end
    
    x = ( x - spm_hdr2.origin(1) )* spm_hdr2.xsize;
    y = ( y - spm_hdr2.origin(2) )* spm_hdr2.ysize;
    z = ( z - spm_hdr2.origin(3) )* spm_hdr2.zsize;
    
    xi = ( xi - hdr.origin(1) )* hdr.xsize;
    yi = ( yi - hdr.origin(2) )* hdr.ysize;
    zi = ( zi - hdr.origin(3) )* hdr.zsize;
    
    if hdr.zdim >1
        spm_dataB = interp3(x,y,z, spm_data2, xi,yi,zi,'nearest');
    else
        spm_dataB = spm_data2;
    end
    
    [D , inds2]= mk_overlay(args.threshold2(1), D, spm_dataB, 513);
    D = mk_overlap(D,inds,inds2);
    
    %configure the colormap:
    %set_func_colors2
    
    
    sDat = guidata(myfig);
    sDat.spm_img2 = spm_data2;
    guidata(myfig,sDat);
    
    
    xstretch = hdr.xdim/spm_hdr2.xdim;
    ystretch = hdr.ydim/spm_hdr2.ydim;
    zstretch = hdr.zdim/spm_hdr2.zdim;
else
    xstretch = 1;
    ystretch = 1;
    zstretch = 1;
end


if ~isempty(args.tseries_file)
    % load up the time series into memory
    isNIFTI=0;
    %first, ,make sure the name is OK.  we want just the root of the time
    filename = args.tseries_file;
    [func_data func_hdr] = read_img(filename);
    
    % save memory?
    %    func_data = int16(func_data);
    
    if isfield(func_hdr,'magic');
        func_hdr = nii2avw_hdr(func_hdr);
        isNIFTI=1
    end
    
    if (~isNIFTI) & (func_hdr.tdim==1)
        root = filename(1:end-8);
        [func_data func_hdr]=read_img_series(root);
    end
    
    % optional in case the origin is not set in the image headers...
    if args.ignore_origin==1
        func_hdr.origin = [1 1 1 0 0]';
    end
end


% determine the first point for the extraction
if isempty(args.xyz)
    x=ceil(hdr.xdim/2);
    y=ceil(hdr.ydim/2);
    z=ceil(hdr.zdim/2);
else
    x = args.xyz(1);
    y = args.xyz(2);
    z = args.xyz(3);
    
    [x,y,z] = mm2vox(hdr, args.xyz)
end

sDat = guidata(myfig);
sDat.x = x;
sDat.y = y;
sDat.z = z;
guidata(myfig,sDat);

% Update the Display of the orthogonal views here
[fig1, fig2, fig3] = ov(hdr,D,x,y,z,0);
if strcmp(computer,'PCWIN')
    set(gcf, 'Renderer','OpenGL');
end

% create the gaussian kernel for the filter (to be used later)
% uses the stats toolbox
g = make_gaussian(49,1,100);
%
oldT1 = args.threshold(1);
oldT2 = args.threshold2(1);

button=1;
while (button ~= 122)  % until they press Z.  122 is ASCII for the Z key
    
    hTmp=get(histFig,'children');
    hLines = findobj(hTmp,'type','line');
    
    sDat = guidata(myfig);
    
    % scale image to fit colormap
    if ~isempty(args.wscale) || isfield(sDat,'wscale')
        if isfield(sDat,'wscale')
            wscale = sDat.wscale;
            args.wscale = wscale;
        else
            wscale = args.wscale;
        end
        D = (anat_data - wscale(1))*256 / (wscale(2)-wscale(1));
        D(find(D>256)) = 256;
        D(find(D<1)) = 1;
    else
        
        range= max(D(:)) - min(D(:));
        %range = 2*std(D(:))
        %D = (D - median(D(:))- range/2 )*256 / range;
        D = (D - min(D(:)))*256 / range;
        %D = (D - median(D(:))- range/2 )*256 / range;
        
    end
    Dscaled = D;
    
    
    % Scale and plot first SPM map
    if ~isempty(args.spm_file) || isfield(sDat,'spm_img')
        if isfield(sDat,'threshold')
            myThresh = sDat.threshold;
            args.threshold = myThresh;
        else
            myThresh = args.threshold;
        end
        
        [D , inds]= mk_overlay(myThresh(1), Dscaled, spm_dataR, 257);
        oldT1 = args.threshold(1);
               
    end
    
    % Scale and plot second SPM map
    if ~isempty(args.spm_file2) || isfield(sDat,'spm_img2')
        if isfield(sDat,'threshold2')
            myThresh2 = sDat.threshold2;
            args.threshold2 = myThresh2;
        else
            myThresh2 = args.threshold2;
        end
        [D , inds2]= mk_overlay(myThresh2(1), D, spm_dataB, 513);
    end
    
    if ~isempty(args.spm_file2) &  ~isempty(args.spm_file)
        D = mk_overlap(D, inds, inds2);
        oldT2 = args.threshold2(1);
    end
    
    % now get into the interactive sampling loop:
    [fig1, fig2, fig3] =  ov(hdr,D,x,y,z,0);
    
    fprintf('\ncoords = (%3.2f, %3.2f, %3.2f) mm,  \ncoords = (%3.2f, %3.2f, %3.2f) vox , \nAnat val= %f',...
        hdr.xsize *( x - hdr.origin(1) ), ...
        hdr.ysize *( y - hdr.origin(2) ), ...
        hdr.zsize *( z - hdr.origin(3) ), ...
        x,y,z, ...
        anat_data(x,y,z));%*anat_scale );
    
    % figure out what the coordinates correspond to in the SPM image
    if ~isempty(args.spm_file)
        % get the values in the stats map
        [mx, my, mz] = vox2mm(hdr, [x,y,z]);
        [xs, ys, zs] = mm2vox(spm_hdr, [mx, my, mz]);
        
    else
        xs = x;
        ys = y;
        zs = z;
        
        spm_hdr=hdr;
    end
    
    % figure out what the coordinates correspond to in the SPM2 image
    if ~isempty(args.spm_file2)
        % get the values in the stats map
        [mx, my, mz] = vox2mm(hdr, [x,y,z]);
        [xs, ys, zs] = mm2vox(spm_hdr2, [mx, my, mz]);
        
        %fprintf('\nSPM2 val= %d', spm_data2(xs,ys,zs));%*spm_scale2 );
        
    end
    
    % extend the coordinates to fill a whole ROI
    % (figure out which voxels get extracted)
    if ~isempty(args.anat_file)
        
        % just in case they forgot to set that flag, if they selected a
        % mask file, it means they are doing a mask ROI
        if ~isempty(args.mask_file)
            args.ROItype='maskFile';
        end
        
        % limits of the ROI
        roi = args.ROIsize;
        
        xmin = max([1 xs-roi]);
        xmax = min([hdr.xdim xs+roi]);
        
        ymin = max([1 ys-roi]);
        ymax = min([hdr.ydim ys+roi]);
        
        zmin = max([1 zs-roi]);
        zmax = min([hdr.zdim zs+roi]);
        
        % first figure which voxels
        switch args.ROItype
            case 'cube'
                [xx,yy,zz] = ndgrid([xmin:xmax], [ymin:ymax], [zmin:zmax]);
                nlist = length(xx(:));
                fx = reshape(xx,nlist,1);
                fy = reshape(yy,nlist,1);
                fz = reshape(zz,nlist,1);
                
                func_xyz = [fx fy fz];   % a list of all voxels within the cube
                
            case 'sphere'
                %nlist = (2*args.ROIsize + 1)^3; % total # of voxels within a cube
                [xx,yy,zz] = ndgrid([xmin:xmax], [ymin:ymax], [zmin:zmax]);
                nlist = length(xx(:));
                fx = reshape(xx,nlist,1);
                fy = reshape(yy,nlist,1);
                fz = reshape(zz,nlist,1);
                
                cube_xyz = [fx fy fz];   % a list of all voxels within the cube
                dist_cube = sqrt(...
                    (spm_hdr.xsize * (fx - xs)).^2 + ...
                    (spm_hdr.ysize * (fy - ys)).^2 + ...
                    (spm_hdr.zsize * (fz - zs)).^2);    % a list of distances in mm
                
                sphere_xyz = cube_xyz(dist_cube <= args.ROIsize, :); % a list of voxels within sphere
                num_voxels = size(sphere_xyz,1); % len_list is the # of voxels within sphere
                
                % keep only those above threshold(1) in the spm_data
                func_xyz =  [];
                if ~isempty(args.spm_file)
                    if args.threshold(1) >= 0
                        for v=1: num_voxels
                            if spm_data(sphere_xyz(v,1), sphere_xyz(v,2), sphere_xyz(v,3)) ...
                                    >= args.threshold(1);
                                func_xyz = [func_xyz; sphere_xyz(v,:)];
                            end
                        end
                    else
                        for v=1: num_voxels
                            if spm_data(sphere_xyz(v,1), sphere_xyz(v,2), sphere_xyz(v,3)) ...
                                    <= args.threshold(1);
                                func_xyz = [func_xyz; sphere_xyz(v,:)];
                            end
                        end
                    end
                    
                    
                    if ~isempty(args.spm_file2)
                        func_xyz2 =  [];
                        if args.threshold2(1) >= 0
                            for v=1: size(func_xyz,1)
                                if spm_data2(func_xyz(v,1), func_xyz(v,2), func_xyz(v,3)) ...
                                        >= args.threshold2(1);
                                    func_xyz2 = [func_xyz2; func_xyz(v,:)];
                                end
                            end
                        else
                            for v=1: size(func_xyz,1)
                                if spm_data2(func_xyz(v,1), func_xyz(v,2), func_xyz(v,3)) ...
                                        <= args.threshold2(1);
                                    func_xyz2 = [func_xyz2; func_xyz(v,:)];
                                end
                            end
                        end
                        func_xyz=func_xyz2;
                    end
                else
                    func_xyz = sphere_xyz;
                end
                
            case 'voxFile'
                if ~isempty(args.voxFile)
                    func_xyz = load(args.voxFile)
                else
                    fprintf('\nERROR: NO VOXEL FILE (args.voxFile) WAS SPECIFIED - ABORT');
                    fprintf('\nI am very disappointed\n');
                end
            case 'maskFile'
                if ~isempty(args.mask_file)
                    mask_hdr = read_hdr(args.mask_file);
                    mask_data = read_img(args.mask_file);
                    mask_data = reshape(mask_data, mask_hdr.xdim, mask_hdr.ydim, mask_hdr.zdim);
                    %func = find(mask_data >= args.threshold(1));
                    func = find(mask_data);
                    [fx, fy, fz] = ind2sub(size(mask_data), func);
                    if ~isempty(args.tseries_file)
                        % convert to time series image coordinates
                        [fx, fy, fz] = vox2mm(mask_hdr, [fx,fy,fz]);
                        [fx, fy, fz] = mm2vox(func_hdr, [fx,fy,fz]);
                    else
                        % convert to the stats image coordinates
                        [fx, fy, fz] = vox2mm(mask_hdr, [fx,fy,fz]);
                        [fx, fy, fz] = mm2vox(spm_hdr, [fx,fy,fz]);
                    end
                    func_xyz = [fx fy fz];
                else
                    fprintf('\nERROR: NO MASK FILE (args.mask_file) WAS SPECIFIED - ABORT');
                    fprintf('\nHow could you ...?\n');
                    return
                end
                %keyboard
            otherwise
                fprintf('\nError. Alowed ROI types are: cube, sphere, voxFile, maskFile.')
                fprintf('\nDo not let it happen again... Exiting\n')
                return
        end
        
        
        
        % fill in the ROI so you know what pixels got extracted
        if ~isempty(func_xyz)
            vx = func_xyz(:,1);
            vy = func_xyz(:,2);
            vz = func_xyz(:,3);
            
            % match the voxels in the spm to the anatomical frame of
            % reference
            
            [vx2, vy2, vz2 ] = vox2mm(spm_hdr, func_xyz);
            [vx2, vy2, vz2 ] = mm2vox(hdr, [vx2, vy2, vz2]);
            anat_xyz = [vx2 vy2 vz2];
            
            vx2 = round(vx2); vy2 = round(vy2); vz2 = round(vz2);
            
            h1 = findobj('tag','fig1');
            zind = find(vz2==z);
            axes(h1(1)),hold on,plot(vy2(zind), vx2(zind),'mx');
            
            h2 = findobj('tag','fig2');
            yind = find(vy2==y);
            axes(h2(1)),hold on,plot(vx2(yind), vz2(yind),'mx');
            
            xind = find(vx2==x);
            
            h3 = findobj('tag','fig3');
            axes(h3(1)),hold on,plot(vy2(xind), vz2(xind),'mx');
            
            
            if ~isempty(args.spm_file)
                spm_val = zeros(size(vx,1),1);
                for p=1:length(spm_val)
                    spm_val(p)= spm_data(vx(p),vy(p),vz(p));
                end
                spm_val = mean(spm_val(find(~isnan(spm_val))));
                fprintf('\nMean ROI val in SPM n.1 = %f -- %d voxels\n', spm_val, length(vx) );
                for p=1:length(vx)
                    mean_anat(p)= anat_data(vx(p),vy(p),vz(p));
                end
                fprintf('\nMean ROI val in underlay = %f -- %d voxels\n', mean(mean_anat), length(vx) );
                
            end
            if ~isempty(args.spm_file2)
                spm_val2 = zeros(size(vx2,1),1);
                for p=1:length(spm_val2)
                    spm_val2(p)= spm_data2(vx(p),vy(p),vz(p));
                end
                spm_val2 = mean(spm_val2(find(~isnan(spm_val2))));
                fprintf('\nMean ROI val in SPM n.2 = %f -- %d voxels\n', spm_val2, length(vx2) );
            end
            drawnow
        else
            fprintf('\nFound no elligible voxels at this location');
            fprintf('\nThat is too bad, I really wanted to extract a time series');
        end
    end
    
    
    
    if button==3 && ~isempty(func_xyz)
        % 6/27/2008: right mouse button means we save pix coordinates to file
        % here we can write those pixels without loading a time course.
        % NB : we save the pixel indices for BOTH the anatomical and
        % functional images
        fprintf('\nsaving:    %s_voxels.dat',args.output_name)
        fprintf('\nsaving:    %s_anvoxels.dat',args.output_name)
        str=sprintf('save %s_voxels.dat func_xyz -ASCII', args.output_name); eval(str);
        str=sprintf('save %s_anvoxels.dat anat_xyz -ASCII', args.output_name); eval(str);
    end
    
    % and extract the time series in the selected voxels
    if ~isempty(func_xyz) & ~isempty(args.tseries_file)
        
        % FIX FOR RESIZE
        [mmx, mmy, mmz] = vox2mm(hdr, [vx,vy,vz]);
        [vx, vy, vz] = mm2vox(func_hdr, [mmx,mmy,mmz]);
        
        xmmBndFunc = func_hdr.xsize * func_hdr.xdim;
        ymmBndFunc = func_hdr.ysize * func_hdr.ydim;
        zmmBndFunc = func_hdr.zsize * func_hdr.zdim;
        
        if ~exist('strObjType','var')
            strObjType = 'image';
        end
        
        strTimeCourseTitle = 'Signal';
        if max(mmx) > xmmBndFunc || max(mmy) > ymmBndFunc || max(mmz) > zmmBndFunc
            fprintf('\nInvalid ROI - exceeds functional image bounds!  Clamping to voxel [1 1 1].\n');
            vx = 1; vy = 1; vz = 1;
            strTimeCourseTitle = 'No Signal';
        end
        
        % END FIX FOR RESIZE
        
        tmp = xtractROI(func_hdr, func_data, vx, vy, vz);
        rawtdata = tmp;
        
        % filtering stuff:
        % tmp = smoothdata2(tmp, TR, 0.009, 0.3, 3);
        if args.doGfilter
            %disp('Gaussian filter ...')
            MeanBefore=mean(tmp);
            tmp = conv(g,tmp-MeanBefore);
            tmp = tmp(50:end-50 )+ MeanBefore;
            %tmp = smoothdata2(tmp, 1, 0.009, 0.4, 11);
            MeanAfter=mean(tmp);
        end
        
        series_mean = mean(tmp);
        series_std = std(tmp);
        
        fprintf('\ntemporal mean: %f , temporal std. dev.: %f', ...
            series_mean, series_std);
        
        if args.doDetrend
            %             disp('detrending ...')
            fprintf('\ndetrending ...');
            dtmp = mydetrend(tmp');
            load coeffs.mat
            tmp=dtmp;
            tmp = 100 * tmp / series_mean;
        else
            % signal change computation:
            % tmp = 100 * (tmp' - series_mean) / series_mean;
            %    tmp = rawtdata;
        end
        
        % Do the plots
        
        
        tdata = tmp;
        subplot 224, plot(tdata,'r'); grid on
        xlabel('scan #'), title(strTimeCourseTitle)
        set(gca,'Position',[ 0.47    0.15    0.40    0.30]);axis tight ;
        set(gca,'tag','tcourse');
        
        
        if button==3 | strcmp(args.ROItype,'maskFile') | args.interact==0 | strcmp(args.ROItype,'voxFile')
            % right mouse button means we save data to file
            fprintf('\nsaving:   %s_tdata.dat, and %s_voxels.dat',...
                args.output_name,args.output_name)
            str=sprintf('save %s_tdata.dat tdata -ASCII', args.output_name); eval(str);
            str=sprintf('save %s_rawtdata.dat rawtdata -ASCII', args.output_name); eval(str);
            str=sprintf('save %s_voxels.dat func_xyz -ASCII', args.output_name); eval(str);
            
            % If the causality flag is on, then we also compute the
            % different maps.
            if args.causalMap
                % fprintf('\nNo Causality Analysis Yet. I am just not ready for that kind of commitment!')
                
                drawnow
                if exist('DesMat.dat')
                    fprintf('\nLoading design matrix (DesMat.dat) to remove known effects')
                    DM = load('DesMat.dat');
                    
                else
                    fprintf('\nDid not find design matrix (DesMat.dat) to remove known effects')
                    DM = [];
                end
                %imgDominateFun(func_hdr, func_data, func_xyz, DM);
                fprintf('\nComputing granger causality maps relative to this cluster ...');
                imgGrangerFun(func_hdr, func_data, func_xyz, DM,1);
                figure ; lightbox('grangerF');
                figure(myfig)
                
                fprintf('\nMoving Granger Results to %s_granger ...', args.output_name);
                str = sprintf('!mkdir %s_granger',args.output_name);				eval(str)
                str = sprintf('!mv granger* %s_granger', args.output_name);			eval(str)
                str = sprintf('!mv %s_*.dat %s_granger', args.output_name ,args.output_name);
                eval(str);
                
            end
            
            if args.doSufNec
                % fprintf('\nNo Causality Analysis Yet. I am just not ready for that kind of commitment!')
                
                if ~exist('initfcm.m','file')
                    fprintf('\n\nI cannot do Causality Analysis - you need the Fuzzy Logic Toolbox!\n\n');
                else
                    
                    drawnow
                    if exist('DesMat.dat')
                        fprintf('\nLoading design matrix (DesMat.dat) to remove known effects')
                        DM = load('DesMat.dat');
                        
                        %imgDominateFun(func_hdr, func_data, func_xyz, DM);
                        fprintf('\nComputing Necessity and Sufficiency maps relative to this cluster ...');
                        imgSufNec(args.tseries_file, func_xyz, DM);
                    else
                        fprintf('\nDid not find design matrix (DesMat.dat) to remove known effects')
                        DM = [];
                        imgSufNec(args.tseries_file, func_xyz);
                    end
                    
                    
                    figure ; lightbox('Sufficiency');
                    figure ; lightbox('Necessity');
                    figure(myfig)
                    
                    fprintf('\nMoving Suf Nec Results to %s_SufNec ...', args.output_name);
                    str = sprintf('!mkdir %s_SufNec',args.output_name);				eval(str)
                    str = sprintf('!mv Events* %s_SufNec', args.output_name);			eval(str)
                    str = sprintf('!mv Sufficiency* %s_SufNec', args.output_name);			eval(str)
                    str = sprintf('!mv Necessity* %s_SufNec', args.output_name);			eval(str)
                    str = sprintf('!mv %s_*.dat %s_SufNec', args.output_name ,args.output_name);
                    eval(str);
                end
            end
            
            % 10/25/2011 - implement a regression based connectivity -
            % regress one pixel's time course from all the others and
            % compute t-score
            if args.doConnect
                fprintf('\n Doing Connectivity analysis relative to this ROI... ');
                if exist('DesMat.dat')
                    fprintf('\n Loading design matrix (DesMat.dat) to remove known effects ...')
                    DM = load('DesMat.dat');
                    
                else
                    fprintf('\n ... Did not find design matrix (DesMat.dat) to remove known effects')
                    DM = [];
                end
                
                
                spm_dataR = imgConnect(func_hdr, func_data, func_xyz, DM);
                
                
            end
            
            
        end
        
        if ~isempty(args.onsets)
            
            [ev_avg ev_std] = event_avg(tdata,args.onsets,args.window,1);
            
            subplot 224, plot(ev_avg,'r');axis tight ; hold off;
            dlha = get(gca,'children');
            set(dlha(:),'LineWidth',2);
            hold on
            subplot 224, errorbar([1:length(ev_avg)], ev_avg,...
                ev_std, ev_std,'r');
            hold off
            subplot(224), title (sprintf('ROI at %d %d %d ', xs , ys, zs))
            set(gca, 'Xtick',[0:2:args.window])
            xlabel('scan #'), ylabel('%signal')
            set(gca,'Position',[ 0.55    0.15    0.40    0.30]);
            
            if button==3 | strcmp(args.ROItype,'maskFile') | args.interact==0
                % right mouse button means we save data to file
                % and if so desired, we compute the causality stuff
                tmp = [ev_avg ev_std];
                fprintf('\nsaving:  %s_avg.dat ',args.output_name)
                str=sprintf('save %s_avg.dat tmp -ASCII', args.output_name); eval(str);
                
            end
            
            % now display the image of event averages
            load allevents
            if isempty(EvFig) || isempty(findobj('tag','01_evfig')) %isempty(strfind(get(EvFig,'tag'),'evfig'))
                EvFig = figure;
                set(gcf,'Position',[1 1 360,320]);
                set(gcf, 'Name', 'Events image');
                set(gcf,'tag','EvFig');
                strTag = getincrementaltag('evfig');
                set(gcf,'tag',strTag);
                
            end
            
            figure(EvFig);
            imagesc(allevents); colorbar
            title('Image of all the events in 2D')
            xlabel('Time (scans)'), ylabel('Event number')
            % return focus to other figure
            figure(myfig);
        end
        
    end
    
    if args.doMovie
        fprintf('\nLooping:\n');
        
        doAVI=0;
        if doAVI
            aviF = avifile(sprintf('%s.avi',args.output_name))
            clear M;
        end
        fmin = min(func_data(:));
        fmax = max(func_data(:));
        range = fmax- fmin;
        
        %set(gcf,'units','normalized');
        if ~exist('hSlider','var')
            hSlider = uicontrol('style','slider');
            set(hSlider,'pos',[10 478 240 34]);
            set(hSlider,'Min',0);
            set(hSlider,'Max',size(func_data,1));
            set(hSlider,'units','normalized');
            
            hTxt = uicontrol('Style','text');
            set(hTxt,'pos',[261 492 27 20]);
            set(hTxt,'BackgroundColor',[1 1 1])
            set(hTxt,'String','1');
            set(hTxt,'units','normalized');
        end
        
        % Add a listener for the slider
        hListener = handle.listener(hSlider,'ActionEvent',{@movieslidergcf,hSlider,hTxt,func_data,func_hdr,fmin,args,myfig,range,vx,vy,vz,roi,func_xyz,spm_hdr});
        
        % Make a button to start the movie
        hGo = uicontrol('Style','pushbutton');
        set(hGo,'pos',[312 492 60 20]);
        set(hGo,'String','Play!');
        set(hGo,'Callback',{@moviegogcf,func_data,func_hdr,fmin,args,myfig,range,vx,vy,vz,roi,doAVI,hSlider,hTxt});
        set(hGo,'units','normalized');
    end
    
    if args.doFFT & exist('tdata')
        if isempty(FFTfig)
            % open a window for displaying the frequency content of the time courses
            FFTfig = figure;
            set(gcf,'Position',[400 1 360,320]);
            set(gcf, 'Name', 'Frequency Spectrum');
            set(gcf,'tag','FFTfig');
            strTag = getincrementaltag('fftfig');
            set(gcf,'tag',strTag);
        end
        figure(FFTfig),hold off,
        fdata = fft(tdata - mean(tdata));
        subplot(211), plot(linspace(0,1,length(fdata)/2+1), abs(fdata(1:end/2+1)),'r')
        title('FFT magnitude (mean removed)')
        xlabel('Frequency'), ylabel('Magnitude')
        subplot(212), plot(linspace(-1,1,length(tdata)), angle(fftshift(fft(tdata - mean(tdata)))),'r')
        title('FFT Phase(mean removed)')
        
        xlabel('Frequency'), ylabel('Phase')
        figure(myfig)
    end
    
    
    
    
    % Get the next user defined point if running in interactive mode
    if (args.interact)
        hFigHist = histFig;
        
        
        oldi = i;        oldj = j;
        if isempty(strfind(get(gcf,'tag'),'histfig'))
            myOut = 0;
            while myOut==0 || myOut==2  % myginput returns 0 for histfig, 2 for ortho
                if strcmpi(get(gcf,'Name'),'ortho')
                    return
                end
                
                % If doing timing stuff, have to get off that axis
                if strfind(get(gcf,'tag'),'myfig')
                    if ~isempty(args.onsets)
                        %axes(h1);
                    end
                    
                    % Call modified version of MATLAB builtin ginput
                    [i j button, myOut, hThisObj] = myginput(1,hLines);
                    

                    
                    if myOut==2
                        hp = get(gca,'Parent');
                        if strcmpi(get(hp,'tag'),'figure1')
                            delete(gca);
                        end
                        
                        if strcmpi(get(gco,'tag'),'GO_button');
                            ortho2005(args);
                        end
                        sObj = get(gco);
                        % if isfield(sObj,'Style') && strcmpi(sObj.Style,'edit')
%                         if isfield(sObj,'Style') && ismember(sObj.Tag,{'wscale_field','th1_field','th2_field', 'NN_field', 'VF_field','TW_field,','ons1_field'})
%                             uiwait(gcf);
%                         end
                        if ismember(sObj.Tag,{'wscale_field','th1_field','th2_field', 'NN_field', 'VF_field','TW_field,','ons1_field'})
                            uiwait(gcf);
                        end
                        strTagObj = get(gco,'tag');
                        switch lower(strTagObj)
                            case 'wscale_field'
                                hMax = findobj(hLines,'tag','anat_hist_scaleMax');
                                hMin = findobj(hLines,'tag','anat_hist_scaleMin');
                                strTmp = get(gco,'string');
                                wscale = str2num(strTmp);
                                set(hMax,'xdata',[wscale(2) wscale(2)]);
                                set(hMin,'xdata',[wscale(1) wscale(1)]);
                            case 'th1_field'
                                % hMax = findobj(hLines,'tag','spm1_hist_scaleMax');
                                hMin = findobj(hLines,'tag','spm1_hist_scaleMin');
                                strTmp = get(gco,'string');
                                spmscale = str2num(strTmp);
                                set(hMin,'xdata',[spmscale(1) spmscale(1)]);
                            case 'th2_field'
                                hMin = findobj(hLines,'tag','spm2_hist_scaleMin');
                                strTmp = get(gco,'string');
                                spmscale = str2num(strTmp);
                                set(hMin,'xdata',[spmscale(1) spmscale(1)]);
                        end
                        figure(myfig)
                        continue
                    end
                    figure(myfig);
                end
                
            end
            
        else
            i=oldi; j=oldj;
        end
        hObj = gco;
        strObjType = get(hObj,'Type');
        get(hObj);
        if i<1 | j<1
            i=oldi;  j=oldj;
        end
        
        % For if click isn't within a subplot.
        if strcmpi(strObjType,'figure') || strcmpi(strObjType,'uicontrol')
            i = oldi;
            j = oldj;
        end
        
        if isempty(args.xyz)
            fprintf('\n---');
            i=round(i);j=round(j);
            fig = gca;
            switch fig
                case fig1
                    x=j;
                    y=i;
                case fig2
                    z=j;
                    x=i;
                case fig3
                    y=i;
                    z=j;
            end
        else
            fprintf('\nClear the text coordinates from the control panel if you want to use the mouse')
            x = args.xyz(1);
            y = args.xyz(2);
            z = args.xyz(3);
            [x, y, z] = mm2vox(hdr, [x,y,z]);
        end
        
        if(button==UPKEY) %30 = up arrow key to grow ROI
            args.ROIsize= args.ROIsize + 1;
            
        elseif(button==DNKEY)  %31 = down arrow key to shrink ROI
            args.ROIsize=  args.ROIsize-1;
            
        elseif(button==RTKEY)  %29 = right arrow key to increase threshold(1) by 10%
            args.threshold(1)=args.threshold(1)*1.1;
            
        elseif(button==LTKEY)  %28 = left arrow key to decrease threshold(1) by 10%
            args.threshold(1) = args.threshold(1)*0.9;
        end
        fprintf('\nNew ROIsize = %0.2f mm , thresh = %0.2f ', ...
            args.ROIsize,args.threshold(1));
        
        sData = guidata(myfig);
        sData.x = x;
        sData.y = y;
        sData.z = z;
        guidata(myfig,sData);
        
    else
        
        fprintf('\nsaving:   %s_tdata.dat, and %s_voxels.dat',...
            args.output_name,args.output_name)
        str=sprintf('save %s_tdata.dat tdata -ASCII', args.output_name); eval(str);
        str=sprintf('save %s_rawtdata.dat rawtdata -ASCII', args.output_name); eval(str);
        
        
        
        break;
    end
    %     % exit the loop by clicking outside or hitting "Z"
    %     if button==1 | button ==3
    %         if i<1 | j<1
    %             break
    %         end
    %     end
    
    if  button==122
        break
    end
    
    if ACTIVE==0
        break
    end
    
end

result = args;
fprintf('\nLater!')
return

% ---------------------------------------------
function strTag = getincrementaltag(strTagPart)
strPat = sprintf('\\d{2}_%s',strTagPart);
iMatch = findobj('-regexp','tag',strPat);
if ~isempty(iMatch)
    casTags = sort(get(iMatch,'tag'));
    if ischar(casTags)
        casTags = {casTags};
    end
    strTagLast = casTags{end};
    numLast = str2double(strTagLast(1:2));
    thisNum = numLast + 1;
else
    thisNum = 1;
end
strNewNum = sprintf('%02d',thisNum);
strTag = sprintf('%s_%s',strNewNum,strTagPart);
