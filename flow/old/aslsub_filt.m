function aslsub(root, navg, first, last, skip,  iscomplex)
%function aslsub(root,navg,first, last, skip, [,iscomplex])
%
% Do all subtractions for a series of AST images 
% Assumes the files are AST pairs, wher the the control is the first image 
% and all others are tags of different duration
%
% root - rootname of the files
% navg - number of averages per point
% first - first image to be used in the averages
% last  - last image to use in the averages
% iscomplex - indicate whether these are complex images
%
%  
% note: (last-first)/2 must be a multiple of navg.
%
% this version filters the raw tagged and control data SEPARATELY
% with a low pass FIR filter using filtfilt (no phase added) .  
%
% The filter was generated by this
% b = (remez(6, [0 0.75 0.9 1], [1 1 0 0])) 
% b =
%     0.1425   -0.1251    0.1526    0.8372    0.1526   -0.1251    0.1425
% 

b = (remez(6, [0 0.3 0.6 1], [1 1 0 0])) ;
freqz(b);

% str = sprintf('%s%04d.hdr',root, first);
% h=read_hdr(str);
% total=2*navg;
% incount=1;
% outcount=1;
% c=[];
% t=[];
% 
% iscomplex=0;
% if nargin==4
%     iscomplex=1;
% end
%     
% 
% for incount = first :2: last-1
%     
%     % read the control ...
%     
%     str=sprintf('%s%04d.img',root,incount );
%     fprintf('\nReading CONTROL image...%s', str);
%     raw = read_img_data(h,str);
%     c = [c ; raw];
%     
%     % read the tag...
%     
%     str=sprintf('%s%04d.img',root,incount+1 );
%     fprintf('\nReading TAG image...%s', str);
%     raw = read_img_data(h,str);
%     t = [t; raw];
%     
% end
warning off
%str = sprintf('%s%04d.hdr',root, first);
%h=read_hdr(str);
total=2*navg;
incount=1;
outcount=1;
%iscomplex = 0;
nargin
if ~isempty(dir([root '*.nii*']))
    [raw, h] = read_nii_img(root);
    h = nii2avw_hdr(h);
else
    [raw, h] = read_img_series(root);
end
% complex subtraction is not implemented here yet
if nargin==5
    iscomplex=0;
end
if nargin==4
    order=1;
end
if iscomplex
    fprintf('\nBuilding Complex images\n');
    if ~isempty(dir(['p_' root '*.nii*']))
        [praw, h] = read_nii_img(['p_' root]);
        h = nii2avw_hdr(h);
    else
        [praw, h] = read_img_series(['p_' root]);
        raw = raw.* exp(-i .* praw/1000);
    end
end
c = raw(first:2:last , :);
t = raw(first+1:2:last , :);



fprintf('\nfiltering...');

% temporal fiter at every voxel:
for vx=1:size(c,2)
    c(:,vx) = filtfilt(b,1, c(:,vx) );
    t(:,vx) = filtfilt(b,1, t(:,vx) );
end


% do the subtraction (% units)
s = c-t;
whos raw s c t
Noutframes =(last-first+1)/(2*navg);
 
out = zeros(Noutframes, h.xdim*h.ydim*h.zdim);
c_out = out;
t_out = out;
index=1;
for count = skip+1 : navg: size(s,1)-navg+1 ;
% do the averaging:
    fprintf('\nAveraging pairs %d to %d ...', count, count+navg-1);
    out(index,:) =   mean(s(count : count+navg-1 , :), 1);
    c_out(index,:) = mean(c(count : count+navg-1 , :), 1);
    t_out(index,:) = mean(t(count : count+navg-1 , :), 1);
    index = index+1;

end
h.tdim = size(out,1);
write_img('tagged.img',abs(t_out),h);
write_img('control.img',abs(c_out),h);
if iscomplex
	write_img('p_tagged.img',1000*angle(t_out),h);
	write_img('p_control.img',1000*angle(c_out),h);
	
	write_img('sub.img',abs(out),h);
	write_img('p_sub.img',1000*angle(out),h);
	else
	write_img('sub.img',out,h);
end

globalmean = mean(out,2);
save subglobalmean.txt globalmean -ascii

h.tdim = 1;

ms = mean(s,1);
mc = mean(c,1);
mt = mean(t,1);
if iscomplex
	write_img('mean_sub.img',abs(ms),h);
	write_img('mean_con.img',abs(mc),h);
	write_img('mean_tag.img',abs(mt),h);
	write_img('p_mean_sub.img',1000*angle(ms),h);
	write_img('p_mean_con.img',1000*angle(mc),h);
	write_img('p_mean_tag.img',1000*angle(mt),h);
else
	write_img('mean_sub.img',ms,h);
	write_img('mean_con.img',mc,h);
	write_img('mean_tag.img',mt,h);
end
%write_hdr('mean_sub.hdr',h);
%write_hdr('mean_con.hdr',h);
%write_hdr('mean_tag.hdr',h);
    
fprintf('\n.....Done\n');
clear c t s
warning on

return
